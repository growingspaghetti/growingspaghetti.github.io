<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Algorithm notes on the back of used envelopes bound in a ring binder</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Project Euler</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> </div></li><li><ol class="section"><li class="chapter-item expanded "><a href="e1.html"><strong aria-hidden="true">1.1.</strong> Multiples of 3 and 5</a></li><li class="chapter-item expanded "><a href="e2.html"><strong aria-hidden="true">1.2.</strong> Even Fibonacci numbers</a></li><li class="chapter-item expanded "><a href="e3.html"><strong aria-hidden="true">1.3.</strong> Largest prime factor</a></li><li class="chapter-item expanded "><a href="e4.html"><strong aria-hidden="true">1.4.</strong> Largest palindrome product</a></li><li class="chapter-item expanded "><a href="e5.html"><strong aria-hidden="true">1.5.</strong> Smallest multiple</a></li><li class="chapter-item expanded "><a href="e6.html"><strong aria-hidden="true">1.6.</strong> Sum square difference</a></li><li class="chapter-item expanded "><a href="e7.html"><strong aria-hidden="true">1.7.</strong> 10001st prime</a></li><li class="chapter-item expanded "><a href="e8.html"><strong aria-hidden="true">1.8.</strong> Largest product in a series</a></li><li class="chapter-item expanded "><a href="e9.html"><strong aria-hidden="true">1.9.</strong> Special Pythagorean triplet</a></li><li class="chapter-item expanded "><a href="e10.html"><strong aria-hidden="true">1.10.</strong> Summation of primes</a></li><li class="chapter-item expanded "><a href="e11.html"><strong aria-hidden="true">1.11.</strong> Largest product in a grid</a></li><li class="chapter-item expanded "><a href="e12.html"><strong aria-hidden="true">1.12.</strong> Highly divisible triangular number</a></li><li class="chapter-item expanded "><a href="e13.html"><strong aria-hidden="true">1.13.</strong> Large sum</a></li><li class="chapter-item expanded "><a href="e14.html"><strong aria-hidden="true">1.14.</strong> Longest Collatz sequence</a></li><li class="chapter-item expanded "><a href="e15.html"><strong aria-hidden="true">1.15.</strong> Lattice paths</a></li><li class="chapter-item expanded "><a href="e16.html"><strong aria-hidden="true">1.16.</strong> Power digit sum</a></li><li class="chapter-item expanded "><a href="e17.html"><strong aria-hidden="true">1.17.</strong> Number letter counts</a></li><li class="chapter-item expanded "><a href="e18.html"><strong aria-hidden="true">1.18.</strong> Maximum path sum I</a></li><li class="chapter-item expanded "><a href="e19.html"><strong aria-hidden="true">1.19.</strong> Counting Sundays</a></li><li class="chapter-item expanded "><a href="e20.html"><strong aria-hidden="true">1.20.</strong> Factorial digit sum</a></li><li class="chapter-item expanded "><a href="e21.html"><strong aria-hidden="true">1.21.</strong> Amicable numbers</a></li><li class="chapter-item expanded "><a href="e22.html"><strong aria-hidden="true">1.22.</strong> Names scores</a></li><li class="chapter-item expanded "><a href="e23.html"><strong aria-hidden="true">1.23.</strong> Non-abundant sums</a></li><li class="chapter-item expanded "><a href="e24.html"><strong aria-hidden="true">1.24.</strong> Lexicographic permutations</a></li><li class="chapter-item expanded "><a href="e25.html"><strong aria-hidden="true">1.25.</strong> 1000-digit Fibonacci number</a></li><li class="chapter-item expanded "><a href="e26.html"><strong aria-hidden="true">1.26.</strong> Reciprocal cycles</a></li><li class="chapter-item expanded "><a href="e27.html"><strong aria-hidden="true">1.27.</strong> Quadratic primes</a></li><li class="chapter-item expanded "><a href="e28.html"><strong aria-hidden="true">1.28.</strong> Number spiral diagonals</a></li><li class="chapter-item expanded "><a href="e29.html"><strong aria-hidden="true">1.29.</strong> Distinct powers</a></li><li class="chapter-item expanded "><a href="e30.html"><strong aria-hidden="true">1.30.</strong> Digit fifth powers</a></li><li class="chapter-item expanded "><a href="e31.html"><strong aria-hidden="true">1.31.</strong> Coin sums</a></li><li class="chapter-item expanded "><a href="e32.html"><strong aria-hidden="true">1.32.</strong> Pandigital products</a></li><li class="chapter-item expanded "><a href="e33.html"><strong aria-hidden="true">1.33.</strong> Digit cancelling fractions</a></li><li class="chapter-item expanded "><a href="e34.html"><strong aria-hidden="true">1.34.</strong> Digit factorials</a></li><li class="chapter-item expanded "><a href="e35.html"><strong aria-hidden="true">1.35.</strong> Circular primes</a></li><li class="chapter-item expanded "><a href="e36.html"><strong aria-hidden="true">1.36.</strong> Double-base palindromes</a></li><li class="chapter-item expanded "><a href="e37.html"><strong aria-hidden="true">1.37.</strong> Truncatable primes</a></li><li class="chapter-item expanded "><a href="e38.html"><strong aria-hidden="true">1.38.</strong> Pandigital multiples</a></li><li class="chapter-item expanded "><a href="e39.html"><strong aria-hidden="true">1.39.</strong> Integer right triangles</a></li><li class="chapter-item expanded "><a href="e40.html"><strong aria-hidden="true">1.40.</strong> Champernowne's constant</a></li><li class="chapter-item expanded "><a href="e41.html"><strong aria-hidden="true">1.41.</strong> Pandigital prime</a></li><li class="chapter-item expanded "><a href="e42.html"><strong aria-hidden="true">1.42.</strong> Coded triangle numbers</a></li><li class="chapter-item expanded "><a href="e43.html"><strong aria-hidden="true">1.43.</strong> Sub-string divisibility</a></li><li class="chapter-item expanded "><a href="e44.html"><strong aria-hidden="true">1.44.</strong> Pentagon numbers</a></li><li class="chapter-item expanded "><a href="e45.html"><strong aria-hidden="true">1.45.</strong> Triangular, pentagonal, and hexagonal</a></li><li class="chapter-item expanded "><a href="e46.html"><strong aria-hidden="true">1.46.</strong> Goldbach's other conjecture</a></li><li class="chapter-item expanded "><a href="e47.html"><strong aria-hidden="true">1.47.</strong> Distinct primes factors</a></li><li class="chapter-item expanded "><a href="e48.html"><strong aria-hidden="true">1.48.</strong> Self powers</a></li><li class="chapter-item expanded "><a href="e49.html"><strong aria-hidden="true">1.49.</strong> Prime permutations</a></li><li class="chapter-item expanded "><a href="e50.html"><strong aria-hidden="true">1.50.</strong> Consecutive prime sum</a></li><li class="chapter-item expanded "><a href="e81.html"><strong aria-hidden="true">1.51.</strong> Path sum: two ways</a></li><li class="chapter-item expanded "><a href="e82.html"><strong aria-hidden="true">1.52.</strong> Path sum: three ways</a></li><li class="chapter-item expanded "><a href="e83.html"><strong aria-hidden="true">1.53.</strong> Path sum: four ways</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Open Data Structures</li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> </div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.1.</strong> ArrayStack</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Data Structures and Algorithms in Java (Michael T. Goodrich)</li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> </div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Scoreboard</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> InsertionSort</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">LeetCode with APAS</li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> </div></li><li><ol class="section"><li class="chapter-item expanded "><a href="l69.html"><strong aria-hidden="true">4.1.</strong> Square root</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="about.html">About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Algorithm notes on the back of used envelopes bound in a ring binder</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>26 April 2021</p>
<p>I haven't ever had a <strong>computer science</strong> class. I'd say I'm behind those people graduated in the field for 48 months. I had to spend some time to understand what is the book shelf like to be for a CS student.</p>
<p>Although it's said that nothing is given so freely as advice, with a wish that what I listed up here is useful not only for myself but also for people, here I'm writing this article that is meant to provide a comprehensive map.</p>
<p>I'd stick to <em><strong>OPEN DATA STRUCTURES</strong></em> and <em><strong>PROJECT EULER</strong></em> mentioned at the bottom of this page, and use the rest of them as supplementary resources.</p>
<h1 id="useful-materials"><a class="header" href="#useful-materials">Useful materials</a></h1>
<p>🎞️🎞️🎞️ <a href="https://www.youtube.com/playlist?list=PLvKZ11Lvt-qnJYP8Ntr-k7rBd6xVq3UhH" target="_blank">Youtube playlist containing all videos listed in this page.</a></p>
<html>
<style>
.thumbnail img {
    width:120px;
    transition: width 0.2s;
    margin: 0.5em;
}
.thumbnail {
    width: 100%;
    text-align: center;
}
.thumbnail img:hover {
    width:600px;
}
</style>
</html>
<h2 id="computer-architecture"><a class="header" href="#computer-architecture">Computer architecture</a></h2>
<p>🎞️ MIT, 9.2.3 The von Neumann Model<br />
Confirm that CPUs have the dedicated <strong>ADDRESS BUS</strong> in addition to the data bus.</p>
<div class="thumbnail">
<a href="https://www.youtube.com/watch?v=H0xGKKpKaRE" target="_blank"><img src="./imgs/address-bus.png"></a>
</div>
<p>🎞️ Inside the CPU - Computerphile<br />
Address bus (2)</p>
<div class="thumbnail">
<a href="https://youtu.be/IAkj32VPcUE?t=246" target="_blank"><img src="./imgs/address-bus-2.png"></a>
</div>
<p>🎞️ Introduction to Von Neuman Architecture (Fetch-Decode-Execute) Cycle<br />
Confirm that instructions <strong>LDD</strong>, <strong>ADD</strong>, <strong>STO</strong>, and data <strong>27</strong>, <strong>35</strong> are stored in memory.<br />
Addressing is the only way to tell the difference of them.</p>
<div class="thumbnail">
<a href="https://youtu.be/u9WK73mCD6U" target="_blank"><img src="./imgs/addressing.png"></a>
</div>
<p>🎞️ Tom Scott, The Fetch-Execute Cycle: What's Your Computer Actually Doing?<br />
Confirm that there's <strong>JUMP</strong> instruction, which will be described for the genesis of the subroutine later.</p>
<div class="thumbnail">
<a href="https://youtu.be/Z5JC9Ve1sfI" target="_blank"><img src="./imgs/jump.png"></a>
</div>
<p>🎞️ The Calculator Wars: A video history of Japan's electronic industry (Part 3)<br />
Confirm that the bit part of the <strong>64bit</strong> and <strong>32bit</strong> CPU describes the addressible memory breadth. What is called <code>usize</code> type, unsigned integer, 64bit length in the case of a x86_64 CPU.<br />
<strong><a href="https://en.wikipedia.org/wiki/Intel_4004" target="_blank">Intel 4004</a></strong> a 4bit processor. The capacity of an address will be mentioned in Open Data Structures as the <em>word length</em>.</p>
<div class="thumbnail">
<a href="https://youtu.be/ansXGewduN4?t=1613" target="_blank"><img src="./imgs/64bit.png"></a>
</div>
<p>🎞️ そろばんで３度目の日本一　西宮市の中３女子<br />
The arithmetics with a set of circuits in CPU must be the same mechanism to a series of skills that the hands perform on a bit-wise abacus in fundamentals.</p>
<div class="thumbnail">
<a href="https://youtu.be/7LZemQttCXE?t=13" target="_blank"><img src="./imgs/abac.png"></a>
</div>
<p>🎞️ Pointers and dynamic memory - stack vs heap<br />
Confirm that there are regions called <strong>STACK FRAMES</strong> for each function call.</p>
<div class="thumbnail">
<a href="https://www.youtube.com/watch?v=_8-ht2AKyH4" target="_blank"><img src="./imgs/stack-frames.png"></a>
</div>
<p>🎞️ freeCodeCamp.org, Pointers in C / C++ [Full Course]<br />
Confirm that jumping is enabled by means of the technique called function pointers, which allows us to use <strong>LOOP</strong> for example.<br />
You might prefer to watch CS50 written below first.</p>
<div class="thumbnail">
<a href="https://youtu.be/zuegQmMdy8M?t=11198" target="_blank"><img src="./imgs/function-pointer.png"></a>
</div>
<p>🎞️ Wheeler Jump - Computerphile<br />
Story behind the <strong>sub-routine</strong></p>
<div class="thumbnail">
<a href="https://youtu.be/zR8V0lq029c" target="_blank"><img src="./imgs/subroutine.png"></a>
</div>
<h2 id="software-development"><a class="header" href="#software-development">Software development</a></h2>
<p>🎞️ CS50 2020 - Lecture 4 - Memory<br />
Confirm the <strong>garbage values</strong> in memory and the <strong>undefined behaviour</strong> in C.</p>
<div class="thumbnail">
<a href="https://youtu.be/NKTfNv2T0FE" target="_blank"><img src="./imgs/garbage-value.png"></a>
</div>
<p>🎞️ CS50 2020 - Lecture 3 - Algorithms<br />
<strong>Finding</strong> and comparison</p>
<div class="thumbnail">
<a href="https://www.youtube.com/watch?v=gR6nycuZKlM" target="_blank"><img src="./imgs/comparison.png"></a>
</div>
<p>🎞️ CS50 2020 - Lecture 5 - Data Structures<br />
Confirm the physical restriction on the consective allocation extension, for the area is possibly already <strong>claimed</strong> by the other.</p>
<div class="thumbnail">
<a href="https://www.youtube.com/watch?v=2T-A_GFuoTo" target="_blank"><img src="./imgs/ordering.png"></a>
</div>
<p>🎞️ Junmin Lee, Golang Tutorial 3 - Golang pointers explained, once and for all<br />
Memory and the <strong>pointer</strong> in summary</p>
<div class="thumbnail">
<a href="https://youtu.be/sTFJtxJXkaY" target="_blank"><img src="./imgs/pointer.png"></a>
</div>
<h2 id="data-structures-and-algorithms"><a class="header" href="#data-structures-and-algorithms">Data structures and algorithms</a></h2>
<p>For your information, the notation <strong>O</strong>, that describes the growth of requirement, is relative and depends on the focus, that is, there's the implicit agreement on what's the base unit when having a discussion about it.</p>
<p>As described in Open Data Structures, the CPU instructions are specific on the devices and compilers, namely, the <strong>Rust</strong> compiler inserts the boundary check to avoid from accessing the garbage values unlike C; and like some CPUs have special circuits designed for the Java byte code execution, it says <strong>ARM</strong> CPUs have optimizations for short condition branching.</p>
<p>It's not about the number of calls. For instance, memory allocation is a heavier operation than the instructions which the <strong>&quot;lenth()&quot;</strong> call produces. For that reason, the concatenation of Strings is faster to scan through all elements to calculate the necessary capacity first than omitting this preparation.<br />
When focusing on a heavier operation, like CS50 does, uneffective parts magnitude wise are not considered.</p>
<p>🎞️ Fyi, MIT, Instruction-level Parallelism</p>
<div class="thumbnail">
<a href="https://youtu.be/IK9OVbj_Ir0" target="_blank"><img src="./imgs/performance.png"></a>
</div>
<p>Fyi, ARM architecture - conditional execution - Wikipedia</p>
<div class="thumbnail">
<a href="https://en.wikipedia.org/wiki/ARM_architecture#Conditional_execution" target="_blank"><img src="./imgs/shortif.png"></a>
</div>
<hr />
<p>🎞️ freeCodeCamp, Data Structures Easy to Advanced Course - Full Tutorial from a Google Engineer<br />
Comprehensive step by step tutorial about data structures. This allowed me to be familier to their names and ready to read books about them.</p>
<ul>
<li><a href="https://github.com/williamfiset/data-structures" target="_blank">https://github.com/williamfiset/data-structures</a></li>
<li><a href="https://github.com/williamfiset/Algorithms" target="_blank">https://github.com/williamfiset/Algorithms</a></li>
</ul>
<div class="thumbnail">
<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM" target="_blank"><img src="./imgs/binary-tree.png"></a>
</div>
<p>🎞️ Spanning Tree, What is Binary Heap<br />
There are sort of confusion in nomenclature, and watching these videos by Brian from CS50 at that timing helped me to understand the 8h data structure tutorial.</p>
<div class="thumbnail">
<a href="https://www.youtube.com/watch?v=AE5I0xACpZs" target="_blank"><img src="./imgs/pq.png"></a>
</div>
<p>🎞️ Spanning Tree, What Are Bloom Filters?</p>
<div class="thumbnail">
<a href="https://www.youtube.com/watch?v=kfFacplFY4Y" target="_blank"><img src="./imgs/broo.png"></a>
</div>
<p>🎞️ Spanning Tree, How Dijkstra's Algorithm Works</p>
<div class="thumbnail">
<a href="https://www.youtube.com/watch?v=EFg3u_E6eHU" target="_blank"><img src="./imgs/di.png"></a>
</div>
<p>🎞️ Spanning Tree, How Do You Calculate a Minimum Spanning Tree?</p>
<div class="thumbnail">
<a href="https://www.youtube.com/watch?v=Yldkh0aOEcg" target="_blank"><img src="./imgs/spa.png"></a>
</div>
<p>🎞️ Junmin Lee, Graph data structure and graph representation (Part 1 of 2)<br />
It was helpful to watch this video at that point not to sink in the confusion.</p>
<div class="thumbnail">
<a href="https://www.youtube.com/watch?v=JDP1OVgoa0Q" target="_blank"><img src="./imgs/gra.png"></a>
</div>
<p>🎞️ Junmin Lee, Data Structures and Algorithms in Go - Heaps</p>
<div class="thumbnail">
<a href="https://www.youtube.com/watch?v=3DYIgTC4T1o&list=PL0q7mDmXPZm7s7weikYLpNZBKk5dCoWm6" target="_blank"><img src="./imgs/heap.png"></a>
</div>
<hr />
<p>📖 Open Data Structures<br />
It took me a while to know there was this book.</p>
<ul>
<li><a href="https://github.com/patmorin/ods/tree/master/java" target="_blank">https://github.com/patmorin/ods/tree/master/java</a></li>
<li><a href="https://github.com/spinute/ods-go" target="_blank">https://github.com/spinute/ods-go</a></li>
<li><a href="https://github.com/o8vm/ods" target="_blank">https://github.com/o8vm/ods rust</a></li>
</ul>
<div class="thumbnail">
<a href="http://opendatastructures.org/" target="_blank"><img src="./imgs/ods.png"></a>
</div>
<p>📖 Algorithms in a Nutshell: A Practical Guide 2nd Edition<br />
I flipped through all pages. I'd stick to Open Data Structures.<br />
As the area overlaps with the 8h video, of course, it was great to see words I read before, like Open Adressing and Broom Filter.</p>
<div class="thumbnail">
<a href="https://www.amazon.com/Algorithms-Nutshell-Practical-George-Heineman/dp/1491948922" target="_blank"><img src="./imgs/aln.png"></a>
</div>
<p>📖 Princeton University, Algorithms (4th Edition)<br />
I haven't read it but it seems Algorithms in a Nutshell and this book are famous ones for programmers (not for mathematicians).</p>
<ul>
<li><a href="https://algs4.cs.princeton.edu/24pq/" target="_blank">2.4 Priority Queues</a></li>
</ul>
<div class="thumbnail">
<a href="https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X" target="_blank"><img src="./imgs/algop.png"></a>
</div>
<p>Additionally, it was comprehensive too. But I'd better stick to Open Data Structures.</p>
<ul>
<li><a href="https://www.cs.bham.ac.uk/~jxb/DSA/dsa.pdf" target="_blank">Lecture Notes for Data Structures and Algorithms (School of Computer ScienceUniversity of Birmingham)</a></li>
</ul>
<hr />
<p>📖 WILLEY, Data Structures and Algorithms in Java, 6th Edition<br />
In fact I read only 4/15 chapters. But it's worth having at office.<br />
It was nice to know about the generics dynamic dispatch and the parameteres in Java are passed by value example, such as <code>badReset(Counter c) {c = new Counter();} //reassign local name c to a new Counter</code>.</p>
<div class="thumbnail">
<a href="https://www.amazon.com/Data-Structures-Algorithms-Java-6th-ebook/dp/B00JDRQF8C" target="_blank"><img src="./imgs/j6.png"></a>
</div>
<p>📖 SAMS, Data Structures and Algorithms in Java 2nd Edition<br />
I haven't read it and probably it's not required if you have Open Data Structures.</p>
<div class="thumbnail">
<a href="https://www.amazon.com/Data-Structures-Algorithms-Java-2nd/dp/0672324539" target="_blank"><img src="./imgs/j2.png"></a>
</div>
<hr />
<p>🖊️ Project Euler<br />
I solved 33 questions so far and it helped me to remember mathematics and to know algorithms.</p>
<ul>
<li><a href="https://euler.stephan-brumme.com/" target="_blank">https://euler.stephan-brumme.com/</a></li>
<li><a href="https://www.nayuki.io/page/project-euler-solutions" target="_blank">https://www.nayuki.io/page/project-euler-solutions</a></li>
<li><a href="https://www.mathblog.dk/project-euler-solutions/" target="_blank">https://www.mathblog.dk/project-euler-solutions/</a></li>
<li><a href="https://www.xarg.org/puzzles/" target="_blank">https://www.xarg.org/puzzles/</a></li>
<li><a href="https://github.com/XiaoTaoWang/Project-Euler" target="_blank">https://github.com/XiaoTaoWang/Project-Euler</a></li>
<li><a href="https://blog.dreamshire.com/category/project-euler-solutions/solutions-1-9/" target="_blank">https://blog.dreamshire.com/category/project-euler-solutions</a></li>
</ul>
<div class="thumbnail">
<a href="https://projecteuler.net/" target="_blank"><img src="./imgs/eu.png"></a>
</div>
<p>As for referring to math handbooks, it looks to me they are the only ones I need to look up.</p>
<p>📖 The Concise Oxford Dictionary of Mathematics</p>
<div class="thumbnail">
<a href="https://www.amazon.com/Concise-Oxford-Dictionary-Mathematics-Reference/dp/0199679592/" target="_blank"><img src="./imgs/om.png"></a>
</div>
<p>📖 Schaum's Outline of Mathematical Handbook of Formulas and Tables, Fifth Edition</p>
<div class="thumbnail">
<a href="https://www.amazon.com/Schaums-Mathematical-Handbook-Formulas-Outlines/dp/1260010538" target="_blank"><img src="./imgs/form.png"></a>
</div>
<p>Alternatively,  <a href="https://cambomaths.files.wordpress.com/2010/03/1300_math_formulas.pdf" target="_blank">1300 Math Formulas PDF</a></p>
<h2 id="compiler-design"><a class="header" href="#compiler-design">Compiler design</a></h2>
<p>I haven't read them but it seems there are some chapters about data structures.</p>
<p>📖 Advanced Compiler Design and Implementation</p>
<div class="thumbnail">
<a href="https://www.amazon.com/Advanced-Compiler-Design-Implementation-Muchnick/dp/1558603204/" target="_blank"><img src="./imgs/cpd.png"></a>
</div>
<p>📖 Compilers: Principles, Techniques, and Tools 2nd Edition</p>
<div class="thumbnail">
<a href="https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811" target="_blank"><img src="./imgs/cmp.png"></a>
</div>
<h1 id="ps"><a class="header" href="#ps">PS</a></h1>
<p>Data structures and algorithms might be easier than the non-pedagogical programming in a sense for its internal perfection and predictability.</p>
<p>I mean, I can imagine you are using <strong>Postman</strong> to check against a service that was provided by some organisation so that you can confirm the functionalities are implemented as described in their documents after experiencing irregular behaviours; you are collating the version of a <strong>Kubernetes'</strong> application in debugging for a runtime error that couldn't be detected with mock tests; or you are in a tunnel to find out idioms unheard of to write a passable <strong>Gradle</strong> script or an industrial level quality test code with the most up-to-date <strong>Mockito</strong> library with an extention that is also unheard of. A warning says I must not click <strong>the back button in the browser</strong>; or a question form doesn't have the option to choose for my answer. To speak ultimately, this kind of problems occurs regardless of using a computer or a sheet of paper. It mustn't be after the date you return the house key that your removel van comes.</p>
<p>As for me, having been stuck in quotidian affairs, I'm poor in certain things to be certified. As you see from this page, I'm so a non-starter literally, which is not what I'm proud of.</p>
<html>
<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vR7HA2byHmvIaxWXOhdLJMXgsyf7M5vx7ZWRU2ZV4qGgIOFrLaehDqONZVPYB_tLZdrCRFmUgMAagf9/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>
</html>
<pre><pre class="playground"><code class="language-rust editable">struct ArithmeticProgression {
    first: i32,
    last: i32,
    diff: i32,
}

impl ArithmeticProgression {
    fn arithmetic_series(&amp;self) -&gt; i32 {
        assert!(self.diff != 0);
        assert!(
            (self.first &gt; self.last) == (0 &gt; self.diff),
            &quot;The relationship between the first element and the last element \
            with the negativity of the common difference is incoherent.&quot;
        );
        let terms = (self.last - self.first) / self.diff + 1;
        assert!(
            self.first + self.diff * (terms - 1) == self.last,
            &quot;The length between the first element, \
            the common difference and the last element is incoherent.&quot;
        );
        (self.first + self.last) * terms / 2
    }
}

fn main() {
    let a = ArithmeticProgression {
        first: 0,
        last: 999,
        diff: 3,
    }
    .arithmetic_series();
    let b = ArithmeticProgression {
        first: 0,
        last: 995,
        diff: 5,
    }
    .arithmetic_series();
    let ab = ArithmeticProgression {
        first: 0,
        last: 999 - 999 % 15,
        diff: 15,
    }
    .arithmetic_series();
    println!(&quot;{}&quot;, a + b - ab);
    assert_eq!(a + b - ab, 233168);

    assert_eq!(
        ArithmeticProgression {
            first: 2,
            last: 14,
            diff: 3
        }
        .arithmetic_series(),
        2 + 5 + 8 + 11 + 14
    );
    assert_eq!(
        ArithmeticProgression {
            first: 3,
            last: 12,
            diff: 3
        }
        .arithmetic_series(),
        3 + 6 + 9 + 12
    );
    assert_eq!(
        ArithmeticProgression {
            first: 1,
            last: 10,
            diff: 1
        }
        .arithmetic_series(),
        (1 + 10) * (10 / 2)
    );
    assert_eq!(
        ArithmeticProgression {
            first: -10,
            last: 10,
            diff: 1
        }
        .arithmetic_series(),
        0
    );
    assert_eq!(
        ArithmeticProgression {
            first: -4,
            last: 2,
            diff: 1
        }
        .arithmetic_series(),
        -4 - 3
    );
    assert_eq!(
        ArithmeticProgression {
            first: 5,
            last: -1,
            diff: -2
        }
        .arithmetic_series(),
        5 + 3 + 1 - 1
    );
    assert_eq!(
        ArithmeticProgression {
            first: 6,
            last: 0,
            diff: -2
        }
        .arithmetic_series(),
        6 + 4 + 2
    );
    assert_eq!(
        ArithmeticProgression {
            first: 6,
            last: 2,
            diff: -2
        }
        .arithmetic_series(),
        6 + 4 + 2
    );
    assert_eq!(
        ArithmeticProgression {
            first: -6,
            last: 0,
            diff: 2
        }
        .arithmetic_series(),
        -6 + -4 + -2
    );
    assert_eq!(
        ArithmeticProgression {
            first: -6,
            last: -2,
            diff: 2
        }
        .arithmetic_series(),
        -6 + -4 + -2
    );
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSaHP7TcUI71uiwljBVfn6M7yFRxgXos451Bcb_q-y0h__0CLFzDZn916HYRaj-y_hfgcS-MUbDsEh6/embed?start=false&loop=false&delayms=60000" frameborder="0"  width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">struct TripleBox {
    i: u64,
    j: u64,
    k: u64,
}

impl TripleBox {
    fn shift(&amp;mut self) {
        self.i = self.j + self.k;
        self.j = self.k + self.i;
        self.k = self.i + self.j;
    }
}

fn main() {
    let mut sum = 0;
    let mut tb = TripleBox { i: 0, j: 1, k: 1 };
    while tb.i &lt;= 4_000_000 {
        sum += tb.i;
        tb.shift()
    }
    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 4613732)
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">struct LuckyClover {
    a: u64,
    b: u64,
    c: u64,
    d: u64,
}

impl LuckyClover {
    fn multiply(&amp;mut self, other: &amp;LuckyClover) {
        let a = self.a * other.a + self.b * other.c;
        let b = self.a * other.b + self.b * other.d;
        let c = self.c * other.a + self.d * other.c;
        let d = self.c * other.b + self.d * other.d;
        self.a = a;
        self.b = b;
        self.c = c;
        self.d = d;
    }
    fn identity_matrix() -&gt; LuckyClover {
        LuckyClover {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
        }
    }
}

fn main() {
    let multiplier = LuckyClover {
        a: 1,
        b: 1,
        c: 1,
        d: 0,
    };
    let cubed = {
        let mut i = LuckyClover::identity_matrix();
        i.multiply(&amp;multiplier);
        i.multiply(&amp;multiplier);
        i.multiply(&amp;multiplier);
        std::mem::drop(multiplier);
        i
    };
    let mut sum = 0;
    let mut fibmatrix = LuckyClover::identity_matrix();
    while fibmatrix.b &lt;= 4_000_000 {
        sum += fibmatrix.b;
        fibmatrix.multiply(&amp;cubed);
    }
    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 4613732)
}
</code></pre></pre>
<html><iframe frameborder="0" width="750" height="750" src="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Atime%3A%3AInstant%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20warm%20up%0A%20%20%20%20assert_eq!(th_fib_matrix(1)%2C%201)%3B%0A%20%20%20%20assert_eq!(th_fib_matrix(2)%2C%201)%3B%0A%20%20%20%20assert_eq!(th_fib_matrix(3)%2C%202)%3B%0A%20%20%20%20assert_eq!(th_fib_matrix(4)%2C%203)%3B%0A%20%20%20%20assert_eq!(th_fib_matrix(5)%2C%205)%3B%0A%20%20%20%20assert_eq!(th_fib_matrix(6)%2C%208)%3B%0A%0A%20%20%20%20assert_eq!(th_fib_linear(1)%2C%201)%3B%0A%20%20%20%20assert_eq!(th_fib_linear(2)%2C%201)%3B%0A%20%20%20%20assert_eq!(th_fib_linear(3)%2C%202)%3B%0A%20%20%20%20assert_eq!(th_fib_linear(4)%2C%203)%3B%0A%20%20%20%20assert_eq!(th_fib_linear(5)%2C%205)%3B%0A%20%20%20%20assert_eq!(th_fib_linear(6)%2C%208)%3B%0A%0A%20%20%20%20%2F%2F%2088%20ns%20(Intel%20i7%203632QM)%0A%20%20%20%20let%20start_matrix%20%3D%20Instant%3A%3Anow()%3B%0A%20%20%20%20assert_eq!(th_fib_matrix(185)%2C%20205697230343233228174223751303346572685)%3B%0A%20%20%20%20let%20duration_matrix%20%3D%20start_matrix.elapsed()%3B%0A%0A%20%20%20%20%2F%2F%20133%20ns%20(Intel%20i7%203632QM)%0A%20%20%20%20let%20start_linear%20%3D%20Instant%3A%3Anow()%3B%0A%20%20%20%20assert_eq!(th_fib_linear(185)%2C%20205697230343233228174223751303346572685)%3B%0A%20%20%20%20let%20duration_linear%20%3D%20start_linear.elapsed()%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Time%20elapsed%20in%20th_fib_matrix()%20%7B%3A%3F%7D%20and%20th_fib_linear()%20%7B%3A%3F%7D%22%2C%0A%20%20%20%20%20%20%20%20duration_matrix%2C%20duration_linear%0A%20%20%20%20)%3B%0A%7D%0A%0Afn%20th_fib_matrix(mut%20th%3A%20u8)%20-%3E%20u128%20%7B%0A%20%20%20%20assert!(th%20%3C%3D%20185%2C%20%22u128%20size%22)%3B%0A%20%20%20%20let%20mut%20result%20%3D%20LuckyClover%3A%3Aidentity_matrix()%3B%0A%20%20%20%20let%20mut%20acc%20%3D%20LuckyClover%20%7B%0A%20%20%20%20%20%20%20%20a%3A%201%2C%0A%20%20%20%20%20%20%20%20b%3A%201%2C%0A%20%20%20%20%20%20%20%20c%3A%201%2C%0A%20%20%20%20%20%20%20%20d%3A%200%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20if%20th%20%25%202%20%3D%3D%201%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20result.multiply(%26acc)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20th%20%3E%3E%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20th%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20acc.square()%3B%0A%20%20%20%20%7D%0A%20%20%20%20result.b%0A%7D%0A%0Afn%20th_fib_linear(th%3A%20u8)%20-%3E%20u128%20%7B%0A%20%20%20%20assert!(th%20%3C%3D%20185%2C%20%22u128%20size%22)%3B%0A%20%20%20%20let%20mut%20triple%20%3D%20%5B0u128%2C%201%2C%201%5D%3B%0A%20%20%20%20for%20_%20in%200..th%20%2F%203%20%7B%0A%20%20%20%20%20%20%20%20shift(%26mut%20triple)%3B%0A%20%20%20%20%7D%0A%20%20%20%20triple%5B(th%20%25%203)%20as%20usize%5D%0A%7D%0A%0Astruct%20LuckyClover%20%7B%0A%20%20%20%20a%3A%20u128%2C%0A%20%20%20%20b%3A%20u128%2C%0A%20%20%20%20c%3A%20u128%2C%0A%20%20%20%20d%3A%20u128%2C%0A%7D%0A%0Aimpl%20LuckyClover%20%7B%0A%20%20%20%20fn%20multiply(%26mut%20self%2C%20other%3A%20%26LuckyClover)%20%7B%0A%20%20%20%20%20%20%20%20let%20a%20%3D%20self.a%20*%20other.a%20%2B%20self.b%20*%20other.c%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%20self.a%20*%20other.b%20%2B%20self.b%20*%20other.d%3B%0A%20%20%20%20%20%20%20%20let%20c%20%3D%20self.c%20*%20other.a%20%2B%20self.d%20*%20other.c%3B%0A%20%20%20%20%20%20%20%20let%20d%20%3D%20self.c%20*%20other.b%20%2B%20self.d%20*%20other.d%3B%0A%20%20%20%20%20%20%20%20self.a%20%3D%20a%3B%0A%20%20%20%20%20%20%20%20self.b%20%3D%20b%3B%0A%20%20%20%20%20%20%20%20self.c%20%3D%20c%3B%0A%20%20%20%20%20%20%20%20self.d%20%3D%20d%3B%0A%20%20%20%20%7D%0A%20%20%20%20fn%20square(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20let%20a%20%3D%20self.a%20*%20self.a%20%2B%20self.b%20*%20self.c%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%20self.a%20*%20self.b%20%2B%20self.b%20*%20self.d%3B%0A%20%20%20%20%20%20%20%20let%20c%20%3D%20self.c%20*%20self.a%20%2B%20self.d%20*%20self.c%3B%0A%20%20%20%20%20%20%20%20let%20d%20%3D%20self.c%20*%20self.b%20%2B%20self.d%20*%20self.d%3B%0A%20%20%20%20%20%20%20%20self.a%20%3D%20a%3B%0A%20%20%20%20%20%20%20%20self.b%20%3D%20b%3B%0A%20%20%20%20%20%20%20%20self.c%20%3D%20c%3B%0A%20%20%20%20%20%20%20%20self.d%20%3D%20d%3B%0A%20%20%20%20%7D%0A%20%20%20%20fn%20identity_matrix()%20-%3E%20LuckyClover%20%7B%0A%20%20%20%20%20%20%20%20LuckyClover%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20a%3A%201%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20b%3A%200%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20c%3A%200%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20d%3A%201%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20shift(triple%3A%20%26mut%20%5Bu128%3B%203%5D)%20%7B%0A%20%20%20%20triple%5B0%5D%20%3D%20triple%5B1%5D%20%2B%20triple%5B2%5D%3B%0A%20%20%20%20triple%5B1%5D%20%3D%20triple%5B2%5D%20%2B%20triple%5B0%5D%3B%0A%20%20%20%20triple%5B2%5D%20%3D%20triple%5B0%5D%20%2B%20triple%5B1%5D%3B%0A%7D%0A"></iframe></html>
<ul>
<li><a href="https://cp-algorithms.com/algebra/binary-exp.html#toc-tgt-1">Binary Exponentiation - CP-Algorithms</a></li>
</ul>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/L-Wzglnm4dM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<p><htmnl><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSTrpjghGiCjA0R9p38sLYptZYTiHKxk_Xljri6TMzeMCjf7lyjq1WSWaIKIJxBDG_sc7dpzfyhbaqz/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html></p>
<pre><pre class="playground"><code class="language-rust editable">fn divide_fully(n: &amp;mut u64, d: u64, side: &amp;mut u64) {
    if *n % d != 0 {
        return;
    }
    while {
        *n /= d;
        *n % d == 0
    } {}
    *side = (*n as f64).sqrt() as u64;
}

fn largest_prime_factor(mut n: u64) -&gt; u64 {
    assert!(n &gt; 1);
    let mut side = (n as f64).sqrt() as u64;
    let basic_primes = [2u64, 3, 5];
    for &amp;d in &amp;basic_primes {
        divide_fully(&amp;mut n, d, &amp;mut side);
        if n == 1 {
            return d;
        }
    }
    let mut divisor = 5u64;
    for i in [2u64, 4].iter().cycle() {
        if divisor &gt; side {
            break;
        }
        divisor += *i;
        divide_fully(&amp;mut n, divisor, &amp;mut side);
        if n == 1 {
            return divisor;
        }
    }
    if n == 1 {
        divisor
    } else {
        n
    }
}

fn main() {
    let ans = largest_prime_factor(600851475143u64);
    assert_eq!(ans, 6857);
    println!(&quot;{}&quot;, ans);
    assert_eq!(largest_prime_factor(60), 5);
    assert_eq!(largest_prime_factor(5), 5);
    assert_eq!(largest_prime_factor(17), 17);
    assert_eq!(largest_prime_factor(6), 3);
    assert_eq!(largest_prime_factor(15), 5);
    assert_eq!(largest_prime_factor(25698751364526), 328513);
    assert_eq!(largest_prime_factor(13195), 29);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">fn largest_prime_factor(mut n: u64) -&gt; u64 {
    assert!(n &gt; 1);
    let mut divisor = 2u64;
    while n != 1 {
        if n % divisor == 0 {
            n /= divisor;
        } else {
            divisor += 1;
        }
    }
    divisor
}

fn main() {
    let ans = largest_prime_factor(600851475143u64);
    assert_eq!(ans, 6857);
    println!(&quot;{}&quot;, ans);
    assert_eq!(largest_prime_factor(60), 5);
    assert_eq!(largest_prime_factor(5), 5);
    assert_eq!(largest_prime_factor(17), 17);
    assert_eq!(largest_prime_factor(6), 3);
    assert_eq!(largest_prime_factor(15), 5);
    assert_eq!(largest_prime_factor(25698751364526), 328513);
    assert_eq!(largest_prime_factor(13195), 29);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTTJxJFxMM7KkbNVNMuhPlLG4EJdhHkaJKgibWTKEeKjuzUlvoNJ-qDBOC9qDxd9FbIS4y-Zf76P5F8/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">fn is_palindrome(a: u32) -&gt; bool {
    let mut t = a;
    let mut b = 0u32;
    while t &gt; 0 {
        b *= 10;
        b += t % 10;
        t /= 10;
    }
    a == b
}

fn update_largest_palindrome_product(lpp: &amp;mut Option&lt;u32&gt;, with: u32) {
    match lpp.as_mut() {
        Some(v) =&gt; *v = with,
        None =&gt; *lpp = Some(with),
    }
}

fn scan_b(a: u32, largest_pp: &amp;mut Option&lt;u32&gt;) {
    let mut b = 999;
    while b &gt;= a {
        let p = a * b;
        if p &lt;= largest_pp.unwrap_or_default() {
            return;
        }
        if is_palindrome(p) {
            update_largest_palindrome_product(largest_pp, p);
        }
        b -= 1;
    }
}

fn main() {
    let mut largest_pal_pro: Option&lt;u32&gt; = None;
    for a in (110..=990).rev().step_by(11) {
        scan_b(a, &amp;mut largest_pal_pro);
    }
    let ans = largest_pal_pro.unwrap();

    println!(&quot;{}&quot;, ans);
    assert_eq!(ans, 906609);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vS0vhb4qKuLM62w4AUrn4DQfhzn9hKKS3NmOkhPK3t30mMhf7wB_KqFh5fz0vmGPZcpjP12FT7tlxZT/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/h86RzlyHfUE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<pre><pre class="playground"><code class="language-rust editable">fn gcd(mut a: u64, mut b: u64) -&gt; u64 {
    if b &gt; a {
        std::mem::swap(&amp;mut a, &amp;mut b);
    }
    assert!(b != 0);
    let r = a % b;
    if r == 0 {
        return b;
    }
    gcd(b, r)
}

fn lcm(a: u64, b: u64) -&gt; u64 {
    a * b / gcd(a, b)
}

fn main() {
    let mut acc = 2u64;
    for n in 3..=20u64 {
        acc = lcm(acc, n);
    }

    println!(&quot;{}&quot;, acc);
    assert_eq!(acc, 232792560);
}
</code></pre></pre>
<hr />
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/xdzZVpqSUm8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Clone)]
struct Factor {
    prime: u32,
    occurrence: u32,
}

fn increment_occurrence(factors: &amp;mut [Option&lt;Factor&gt;; 20], p: u32) {
    if let Some(f) = factors[p as usize].as_mut() {
        f.occurrence += 1;
        return;
    }
    factors[p as usize] = Some(Factor {
        prime: p,
        occurrence: 1,
    });
}

fn list_factors(mut n: u32) -&gt; [Option&lt;Factor&gt;; 20] {
    assert!(n &lt;= 20);
    let mut factors: [Option&lt;Factor&gt;; 20] = Default::default();
    let mut d = 2u32;
    while n &gt; 1 {
        while n % d == 0 {
            increment_occurrence(&amp;mut factors, d);
            n /= d;
        }
        d += 1;
    }
    factors
}

fn merge(factors: &amp;mut [Option&lt;Factor&gt;; 20], b: &amp;[Option&lt;Factor&gt;; 20]) {
    for it in b.iter().zip(factors.iter_mut()) {
        match it {
            (Some(bf), None) =&gt; *it.1 = Some(bf.clone()),
            (Some(bf), Some(f)) if bf.occurrence &gt; f.occurrence =&gt; {
                f.occurrence = bf.occurrence
            },
            _ =&gt; continue,
        }
    }
}

fn main() {
    let mut factors: [Option&lt;Factor&gt;; 20] = Default::default();
    for n in 2..=20u32 {
        let local_factors = list_factors(n);
        merge(&amp;mut factors, &amp;local_factors);
    }
    let mut acc = 1u32;
    for o in &amp;factors {
        if let Some(f) = o {
            acc *= f.prime.pow(f.occurrence);
        }
    }

    println!(&quot;{}&quot;, acc);
    assert_eq!(acc, 232792560);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTP9y24LtmU7xc2aa330SN3Ckv41Nhh_Syv8CHEGfe7SsPqUlmIPoXfReOZbVaJWUGS_WXD6L2X7vql/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">struct Sequence {
    n: u64,
}

impl Sequence {
    fn sum_of_squares(&amp;self) -&gt; u64 {
        self.n * (self.n + 1) * (2 * self.n + 1) / 6
    }
    fn sum(&amp;self) -&gt; u64 {
        (1 + self.n) * self.n / 2
    }
}

fn main() {
    let s = Sequence{n: 100};
    let sum = s.sum();
    let diff = sum * sum - s.sum_of_squares();

    println!(&quot;{}&quot;, diff);
    assert_eq!(diff, 25164150);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSQMS02Bs8MWMfHRChuI3eTMbxC-Anx7tUPAGemmKWugKFVup2d25ipBwcU5OQdcxHluC3wQxY6M9Bp/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="https://www.visnos.com/demos/sieve-of-eratosthenes">Sieve of Eratosthenes, number square, view multiples and prime numbers - visnos.com</a></li>
</ul>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/2JkpuE_8uaI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<pre><pre class="playground"><code class="language-rust editable">fn rule_out(sieve: &amp;mut Vec&lt;bool&gt;, prime: usize) {
    for i in (prime * prime..sieve.len()).step_by(prime) {
        sieve[i] = false;
    }
}

fn rule_out_from_previous_position(sieve: &amp;mut Vec&lt;bool&gt;, prime: usize, pp: usize) {
    for i in (prime * prime..sieve.len()).step_by(prime) {
        if i &lt; pp {
            continue;
        }
        sieve[i] = false;
    }
}

fn extend(sieve: &amp;mut Vec&lt;bool&gt;, primes: &amp;Vec&lt;usize&gt;) {
    let previous_len = sieve.len();
    sieve.extend(vec![true; previous_len]);
    for &amp;p in primes {
        rule_out_from_previous_position(sieve, p, previous_len);
    }
}

fn main() {
    let mut counter = 2u32;
    let mut sieve = vec![true; 10000];
    let mut primes: Vec&lt;usize&gt; = vec![];
    let mut cursor = 5usize;
    let n = 'exploration: loop {
        let ite = [2usize, 4].iter().cycle();
        for i in ite {
            if cursor &gt;= sieve.len() {
                break;
            }
            if !sieve[cursor] {
                cursor += i;
                continue;
            }
            counter += 1;
            if counter == 10001 {
                break 'exploration cursor as u64;
            }
            &amp;primes.push(cursor);
            rule_out(&amp;mut sieve, cursor);
            cursor += i;
        }
        extend(&amp;mut sieve, &amp;primes);
    };

    println!(&quot;{}&quot;, n);
    assert_eq!(n, 104743);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">fn is_prime(n: u64) -&gt; bool {
    if n &lt; 2 {
        return false;
    }
    if n == 2 || n == 3 || n == 5 {
        return true;
    }
    for d in &amp;[2u64, 3, 5] {
        if n % *d == 0 {
            return false;
        }
    }

    let side = (n as f64).sqrt() as u64;
    let mut d = 5u64;
    for i in [2u64, 4].iter().cycle() {
        if d &gt; side {
            break;
        }
        d += *i;
        if n % d == 0 {
            return false;
        }
    }
    true
}

fn main() {
    let mut n = 0u64;
    let mut counter = 0u32;
    while counter &lt; 10001 {
        n += 1;
        if is_prime(n) {
            counter += 1;
        }
    }
    
    println!(&quot;{}&quot;, n);
    assert_eq!(n, 104743);
}
</code></pre></pre>
<ul>
<li><a href="./e3.html">Q.3 Largest prime factor</a></li>
</ul>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTEWTgdLfAldnJUzh6V60O0nKBBOaW7c62PG1N8pI2WPrHzCXCumfBSeJm8BvtmaMQRb7adqd8AtcWJ/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let thousand_digits = &quot;7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450&quot;;
    let zero = '0' as u8;
    let digits = thousand_digits
        .chars()
        .map(|c| c as u8 - zero)
        .collect::&lt;Vec&lt;u8&gt;&gt;();
    let mut max = 0u64;
    for i in 0..digits.len() - 13 {
        let tmp = digits[i..i + 13].iter().map(|&amp;d| d as u64).product();
        max = std::cmp::max(max, tmp);
    }

    println!(&quot;{}&quot;, max);
    assert_eq!(max, 23514624000);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTgPBoDy_VKs7ueLoACi3jIhlBTjL9t0-YJ9neaBWqF6nRTr-KM_y0l7a1ReHddjGLlDgpArbSzZS_D/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e39.html">Q.39 Integer right triangles</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut ans = None;
    'exploration: for m in 2..=(499f32.sqrt() as u32) {
        for n in 1..m {
            let a = m * m - n * n;
            let b = 2 * m * n;
            let c = m * m + n * n;
            if a + b + c == 1000 {
                ans = Some(a * b * c);
                break 'exploration;
            }
        }
    }

    println!(&quot;{:?}&quot;, ans);
    assert_eq!(ans.unwrap(), 31875000);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSDrcKWHFjeKXjPU8Imn_bIxq0SFnTdaY00LN6i4LCVPSkAm-zdfUxqIJOYvKLibFpK3WCuqaSmrEQS/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e7.html">Q.7 10001st prime</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct Index {
    i: usize,
    _ite: Box&lt;dyn Iterator&lt;Item = usize&gt;&gt;,
}

impl Index {
    fn increment(&amp;mut self) {
        self.i += self._ite.next().unwrap();
    }
    fn new() -&gt; Self {
        Self {
            i: 5,
            _ite: Box::new(vec![2usize, 4].into_iter().cycle()),
        }
    }
}

fn rule_out(sieve: &amp;mut [bool; 2_000_001], prime: usize) {
    for i in (prime * prime..sieve.len()).step_by(prime) {
        sieve[i] = false;
    }
}

fn main() {
    let mut sieve = [true; 2_000_001];
    let sqrt = (sieve.len() as f32).sqrt() as usize;
    let mut sum = 2u64 + 3;
    let mut index = Index::new();
    while index.i &lt;= sqrt {
        if sieve[index.i] {
            sum += index.i as u64;
            rule_out(&amp;mut sieve, index.i);
        }
        index.increment();
    }
    while index.i &lt; sieve.len() {
        if sieve[index.i] {
            sum += index.i as u64;
        }
        index.increment();
    }

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 142913828922);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQDTvqnzpaJQNzfnw-BfhpzPoNpZtxrjYAwIp80D7oHaoXxVUEavnSf9FxKxnDLlRgqqaQNZHZZ4Ov9/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let matrix = [
        [
            08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08,
        ],
        [
            49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00,
        ],
        [
            81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65,
        ],
        [
            52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91,
        ],
        [
            22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80,
        ],
        [
            24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50,
        ],
        [
            32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70,
        ],
        [
            67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21,
        ],
        [
            24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72,
        ],
        [
            21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95,
        ],
        [
            78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92,
        ],
        [
            16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57,
        ],
        [
            86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58,
        ],
        [
            19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40,
        ],
        [
            04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66,
        ],
        [
            88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69,
        ],
        [
            04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36,
        ],
        [
            20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16,
        ],
        [
            20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54,
        ],
        [
            01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48,
        ],
    ];

    let mut max = 0u32;

    // →
    for y in matrix.iter() {
        for x in 3..matrix.len() {
            if let (Some(a), Some(b), Some(c), Some(d)) =
                (y.get(x - 3), y.get(x - 2), y.get(x - 1), y.get(x))
            {
                max = std::cmp::max(max, a * b * c * d);
            }
        }
    }

    // ↓
    for x in 0..matrix.len() {
        for y in 3..matrix.len() {
            if let (Some(a), Some(b), Some(c), Some(d)) = (
                matrix.get(y - 3).and_then(|r| r.get(x)),
                matrix.get(y - 2).and_then(|r| r.get(x)),
                matrix.get(y - 1).and_then(|r| r.get(x)),
                matrix.get(y).and_then(|r| r.get(x)),
            ) {
                max = std::cmp::max(max, a * b * c * d);
            }
        }
    }

    // ↘
    for x in 3..matrix.len() {
        for y in 3..matrix.len() {
            if let (Some(a), Some(b), Some(c), Some(d)) = (
                matrix.get(y - 3).and_then(|r| r.get(x - 3)),
                matrix.get(y - 2).and_then(|r| r.get(x - 2)),
                matrix.get(y - 1).and_then(|r| r.get(x - 1)),
                matrix.get(y).and_then(|r| r.get(x)),
            ) {
                max = std::cmp::max(max, a * b * c * d);
            }
        }
    }

    // ↙
    for x in 3..matrix.len() {
        for y in 0..matrix.len() - 3 {
            if let (Some(a), Some(b), Some(c), Some(d)) = (
                matrix.get(y + 3).and_then(|r| r.get(x - 3)),
                matrix.get(y + 2).and_then(|r| r.get(x - 2)),
                matrix.get(y + 1).and_then(|r| r.get(x - 1)),
                matrix.get(y).and_then(|r| r.get(x)),
            ) {
                max = std::cmp::max(max, a * b * c * d);
            }
        }
    }

    println!(&quot;{}&quot;, max);
    assert_eq!(max, 70600674);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">struct Square {
    _matrix: [[u32; 20]; 20],
    _x: usize,
    _y: usize,
    _width: usize,
}

impl Square {
    fn new(matrix: [[u32; 20]; 20]) -&gt; Self {
        assert!(matrix.len() == 0 || matrix.len() == matrix[0].len());
        Self {
            _x: 0,
            _y: 0,
            _matrix: matrix,
            _width: matrix.len(),
        }
    }
    fn width(&amp;self) -&gt; usize {
        self._width
    }
    fn set_cursor(&amp;mut self, x: usize, y: usize) {
        self._x = x;
        self._y = y;
    }
    fn east_product(&amp;self, adj_len: usize) -&gt; Result&lt;u32, ()&gt; {
        if self._x + adj_len &gt; self._matrix.len() {
            return Err(());
        }
        let p = (0..adj_len)
            .map(|a| self._matrix[self._y][self._x + a])
            .product::&lt;u32&gt;();
        Ok(p)
    }
    fn south_product(&amp;self, adj_len: usize) -&gt; Result&lt;u32, ()&gt; {
        if self._y + adj_len &gt; self._matrix.len() {
            return Err(());
        }
        let p = (0..adj_len)
            .map(|a| self._matrix[self._y + a][self._x])
            .product::&lt;u32&gt;();
        Ok(p)
    }
    fn south_east_product(&amp;self, adj_len: usize) -&gt; Result&lt;u32, ()&gt; {
        if self._y + adj_len &gt; self._matrix.len() {
            return Err(());
        }
        if self._x + adj_len &gt; self._matrix.len() {
            return Err(());
        }
        let p = (0..adj_len)
            .map(|a| self._matrix[self._y + a][self._x + a])
            .product::&lt;u32&gt;();
        Ok(p)
    }
    fn south_west_product(&amp;self, adj_len: usize) -&gt; Result&lt;u32, ()&gt; {
        if self._y + adj_len &gt; self._matrix.len() {
            return Err(());
        }
        if self._x &lt; adj_len - 1 {
            return Err(());
        }
        let p = (0..adj_len)
            .map(|a| self._matrix[self._y + a][self._x - a])
            .product::&lt;u32&gt;();
        Ok(p)
    }
}

fn main() {
    let mut square = Square::new([
        [
            08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08,
        ],
        [
            49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00,
        ],
        [
            81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65,
        ],
        [
            52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91,
        ],
        [
            22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80,
        ],
        [
            24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50,
        ],
        [
            32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70,
        ],
        [
            67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21,
        ],
        [
            24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72,
        ],
        [
            21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95,
        ],
        [
            78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92,
        ],
        [
            16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57,
        ],
        [
            86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58,
        ],
        [
            19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40,
        ],
        [
            04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66,
        ],
        [
            88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69,
        ],
        [
            04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36,
        ],
        [
            20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16,
        ],
        [
            20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54,
        ],
        [
            01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48,
        ],
    ]);

    let mut max = 0u32;
    for i in 0..square.width() {
        for j in 0..square.width() {
            square.set_cursor(i, j);
            if let Ok(p) = square.east_product(4) {
                max = std::cmp::max(max, p);
            }
            if let Ok(p) = square.south_product(4) {
                max = std::cmp::max(max, p);
            }
            if let Ok(p) = square.south_east_product(4) {
                max = std::cmp::max(max, p);
            }
            if let Ok(p) = square.south_west_product(4) {
                max = std::cmp::max(max, p);
            }
        }
    }

    println!(&quot;{}&quot;, max);
    assert_eq!(max, 70600674);
}
</code></pre></pre>
<blockquote>
<p>They both store data in a linear contiguous array where accessing or iterating is both an O(1) operation so there's no difference in performance.</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/60583618/performance-of-rust-vector-vect-versus-array-t-n">Performance of Rust vector (<code>Vec&lt;T&gt;</code>) versus array (<code>[T; n]</code>) [closed]</a></p>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTUzg1DwUVVPjMo47WhaQsHfCnvNIQ7Kkon5Bap_TWFpgsErv3FrrGagF_zJpF0G50ThPSkBoiGvq9B/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e3.html">Q.3 Largest prime factor</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct TriangleNumber {
    _nth: u64,
    _primes: Vec&lt;u64&gt;,
    _num_div_even: u64,
    _num_div_odd: u64,
}

trait Divisors {
    fn number_of_divisors(&amp;self) -&gt; u64;
}

impl TriangleNumber {
    fn new() -&gt; Self {
        Self {
            _nth: 3,
            _num_div_even: 2,
            _num_div_odd: 2,
            _primes: vec![2, 3],
        }
    }
    fn num(&amp;self) -&gt; u64 {
        self._nth * (self._nth + 1) / 2
    }
    fn _divide_fully(&amp;self, n: &amp;mut u64, d: u64, side: &amp;mut u64, count: &amp;mut u64) {
        if *n % d != 0 {
            return;
        }
        let mut exp = 0u64;
        while {
            *n /= d;
            exp += 1;
            *n % d == 0
        } {}
        *side = (*n as f64).sqrt() as u64;
        *count *= exp + 1;
    }
    fn _num_of_divisors(&amp;mut self, mut n: u64) -&gt; u64 {
        let mut count = 1u64;
        let mut side = (n as f64).sqrt() as u64;
        for &amp;p in self._primes.iter() {
            if p &gt; side || n == 1 {
                break;
            }
            self._divide_fully(&amp;mut n, p, &amp;mut side, &amp;mut count);
        }
        if n != 1 {
            count *= 2;
            self._primes.push(n);
        }
        count
    }
    fn increment(&amp;mut self) {
        self._nth += 1;
        if self._nth % 2 == 0 {
            self._num_div_odd = self._num_of_divisors(self._nth + 1);
        } else {
            self._num_div_even = self._num_of_divisors((self._nth + 1) / 2);
        }
    }
}

impl Divisors for TriangleNumber {
    fn number_of_divisors(&amp;self) -&gt; u64 {
        self._num_div_even * self._num_div_odd
    }
}

fn main() {
    let mut triangle_number = TriangleNumber::new();
    while triangle_number.number_of_divisors() &lt;= 500 {
        triangle_number.increment();
    }
    let ans = triangle_number.num();

    println!(&quot;{}&quot;, ans);
    assert_eq!(ans, 76576500);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vRdM4jhtEGd0_oHBJKN8jN5IH3S_81tR0DRECcChEHe8lujDyNgnXO7Xi3uiQPYrcV-Spgn90uP52N8/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<p><a href="e13.html#variable-size">Go to 2. Variable-size input solution</a>
<a name="fixed-size"><h2 id="1-fixed-size-input-solution"><a class="header" href="#1-fixed-size-input-solution">1. Fixed-size input solution</a></h2></a></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let input_digits = 50usize;
    let container_digits = 10usize;
    let overflow_threshold = 10u64.pow(container_digits as u32);

    let mut sum = 0u64;
    let mut carry = 0u64;
    for i in 0..input_digits / container_digits {
        let chunk_begin = input_digits - container_digits * (i + 1);
        let chunk_end = input_digits - container_digits * i;
        sum = FIFTY_DIGIT_NUMBERS
            .iter()
            .map(|&amp;s| &amp;s[chunk_begin..chunk_end])
            .map(|s| s.parse::&lt;u64&gt;().unwrap())
            .sum::&lt;u64&gt;()
            + carry;
        carry = sum / overflow_threshold;
    }

    let display_threshold = 10u64.pow(10);
    while sum &gt;= display_threshold {
        sum /= 10;
    }

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 5537376230);
}

const FIFTY_DIGIT_NUMBERS: [&amp;str; 100] = [
    &quot;37107287533902102798797998220837590246510135740250&quot;,
    &quot;46376937677490009712648124896970078050417018260538&quot;,
    &quot;74324986199524741059474233309513058123726617309629&quot;,
    &quot;91942213363574161572522430563301811072406154908250&quot;,
    &quot;23067588207539346171171980310421047513778063246676&quot;,
    &quot;89261670696623633820136378418383684178734361726757&quot;,
    &quot;28112879812849979408065481931592621691275889832738&quot;,
    &quot;44274228917432520321923589422876796487670272189318&quot;,
    &quot;47451445736001306439091167216856844588711603153276&quot;,
    &quot;70386486105843025439939619828917593665686757934951&quot;,
    &quot;62176457141856560629502157223196586755079324193331&quot;,
    &quot;64906352462741904929101432445813822663347944758178&quot;,
    &quot;92575867718337217661963751590579239728245598838407&quot;,
    &quot;58203565325359399008402633568948830189458628227828&quot;,
    &quot;80181199384826282014278194139940567587151170094390&quot;,
    &quot;35398664372827112653829987240784473053190104293586&quot;,
    &quot;86515506006295864861532075273371959191420517255829&quot;,
    &quot;71693888707715466499115593487603532921714970056938&quot;,
    &quot;54370070576826684624621495650076471787294438377604&quot;,
    &quot;53282654108756828443191190634694037855217779295145&quot;,
    &quot;36123272525000296071075082563815656710885258350721&quot;,
    &quot;45876576172410976447339110607218265236877223636045&quot;,
    &quot;17423706905851860660448207621209813287860733969412&quot;,
    &quot;81142660418086830619328460811191061556940512689692&quot;,
    &quot;51934325451728388641918047049293215058642563049483&quot;,
    &quot;62467221648435076201727918039944693004732956340691&quot;,
    &quot;15732444386908125794514089057706229429197107928209&quot;,
    &quot;55037687525678773091862540744969844508330393682126&quot;,
    &quot;18336384825330154686196124348767681297534375946515&quot;,
    &quot;80386287592878490201521685554828717201219257766954&quot;,
    &quot;78182833757993103614740356856449095527097864797581&quot;,
    &quot;16726320100436897842553539920931837441497806860984&quot;,
    &quot;48403098129077791799088218795327364475675590848030&quot;,
    &quot;87086987551392711854517078544161852424320693150332&quot;,
    &quot;59959406895756536782107074926966537676326235447210&quot;,
    &quot;69793950679652694742597709739166693763042633987085&quot;,
    &quot;41052684708299085211399427365734116182760315001271&quot;,
    &quot;65378607361501080857009149939512557028198746004375&quot;,
    &quot;35829035317434717326932123578154982629742552737307&quot;,
    &quot;94953759765105305946966067683156574377167401875275&quot;,
    &quot;88902802571733229619176668713819931811048770190271&quot;,
    &quot;25267680276078003013678680992525463401061632866526&quot;,
    &quot;36270218540497705585629946580636237993140746255962&quot;,
    &quot;24074486908231174977792365466257246923322810917141&quot;,
    &quot;91430288197103288597806669760892938638285025333403&quot;,
    &quot;34413065578016127815921815005561868836468420090470&quot;,
    &quot;23053081172816430487623791969842487255036638784583&quot;,
    &quot;11487696932154902810424020138335124462181441773470&quot;,
    &quot;63783299490636259666498587618221225225512486764533&quot;,
    &quot;67720186971698544312419572409913959008952310058822&quot;,
    &quot;95548255300263520781532296796249481641953868218774&quot;,
    &quot;76085327132285723110424803456124867697064507995236&quot;,
    &quot;37774242535411291684276865538926205024910326572967&quot;,
    &quot;23701913275725675285653248258265463092207058596522&quot;,
    &quot;29798860272258331913126375147341994889534765745501&quot;,
    &quot;18495701454879288984856827726077713721403798879715&quot;,
    &quot;38298203783031473527721580348144513491373226651381&quot;,
    &quot;34829543829199918180278916522431027392251122869539&quot;,
    &quot;40957953066405232632538044100059654939159879593635&quot;,
    &quot;29746152185502371307642255121183693803580388584903&quot;,
    &quot;41698116222072977186158236678424689157993532961922&quot;,
    &quot;62467957194401269043877107275048102390895523597457&quot;,
    &quot;23189706772547915061505504953922979530901129967519&quot;,
    &quot;86188088225875314529584099251203829009407770775672&quot;,
    &quot;11306739708304724483816533873502340845647058077308&quot;,
    &quot;82959174767140363198008187129011875491310547126581&quot;,
    &quot;97623331044818386269515456334926366572897563400500&quot;,
    &quot;42846280183517070527831839425882145521227251250327&quot;,
    &quot;55121603546981200581762165212827652751691296897789&quot;,
    &quot;32238195734329339946437501907836945765883352399886&quot;,
    &quot;75506164965184775180738168837861091527357929701337&quot;,
    &quot;62177842752192623401942399639168044983993173312731&quot;,
    &quot;32924185707147349566916674687634660915035914677504&quot;,
    &quot;99518671430235219628894890102423325116913619626622&quot;,
    &quot;73267460800591547471830798392868535206946944540724&quot;,
    &quot;76841822524674417161514036427982273348055556214818&quot;,
    &quot;97142617910342598647204516893989422179826088076852&quot;,
    &quot;87783646182799346313767754307809363333018982642090&quot;,
    &quot;10848802521674670883215120185883543223812876952786&quot;,
    &quot;71329612474782464538636993009049310363619763878039&quot;,
    &quot;62184073572399794223406235393808339651327408011116&quot;,
    &quot;66627891981488087797941876876144230030984490851411&quot;,
    &quot;60661826293682836764744779239180335110989069790714&quot;,
    &quot;85786944089552990653640447425576083659976645795096&quot;,
    &quot;66024396409905389607120198219976047599490197230297&quot;,
    &quot;64913982680032973156037120041377903785566085089252&quot;,
    &quot;16730939319872750275468906903707539413042652315011&quot;,
    &quot;94809377245048795150954100921645863754710598436791&quot;,
    &quot;78639167021187492431995700641917969777599028300699&quot;,
    &quot;15368713711936614952811305876380278410754449733078&quot;,
    &quot;40789923115535562561142322423255033685442488917353&quot;,
    &quot;44889911501440648020369068063960672322193204149535&quot;,
    &quot;41503128880339536053299340368006977710650566631954&quot;,
    &quot;81234880673210146739058568557934581403627822703280&quot;,
    &quot;82616570773948327592232845941706525094512325230608&quot;,
    &quot;22918802058777319719839450180888072429661980811197&quot;,
    &quot;77158542502016545090413245809786882778948721859617&quot;,
    &quot;72107838435069186155435662884062257473692284509516&quot;,
    &quot;20849603980134001723930671666823555245252804609722&quot;,
    &quot;53503534226472524250874054075591789781264330331690&quot;,
];
</code></pre></pre>
<hr />
<p><a href="e13.html#fixed-size">Go to 1. Fixed-size input solution</a> 
<a name="variable-size"><h2 id="2-variable-size-input-solution"><a class="header" href="#2-variable-size-input-solution">2. Variable-size input solution</a></h2></a> </p>
<pre><pre class="playground"><code class="language-rust editable">struct BigNum {
    a: Vec&lt;u64&gt;,
}

fn paging(b: &amp;str, page: usize, unit: usize) -&gt; Option&lt;&amp;str&gt; {
    let len = b.len();
    if len &lt;= unit &amp;&amp; page == 0 {
        return Some(b);
    } else if len &lt;= unit &amp;&amp; page &gt; 0 {
        return None;
    }
    let end = len as isize - page as isize * unit as isize;
    if end &lt;= 0 {
        return None;
    }
    let begin = end - unit as isize;
    if begin &lt; 0 {
        Some(&amp;b[0..end as usize])
    } else {
        Some(&amp;b[begin as usize..end as usize])
    }
}

impl BigNum {
    const TEN_MIL: u64 = 10_000_000_000;
    const TEN_MIL_STR_CAP: usize = 10;
    fn new() -&gt; Self {
        Self { a: vec![] }
    }
    fn merge(&amp;mut self, page: usize, n: u64, carry: &amp;mut u64) {
        if self.a.get(page).is_none() {
            self.a.push(0u64)
        }
        if let Some(con) = self.a.get_mut(page) {
            *con += n + *carry;
            if *con &lt; Self::TEN_MIL {
                *carry = 0;
                return;
            }
            *carry = 1;
            *con -= Self::TEN_MIL;
        }
    }
    fn add(&amp;mut self, b: &amp;str) {
        let mut p = 0usize;
        let mut carry = 0u64;
        while let Some(s) = paging(&amp;b, p, Self::TEN_MIL_STR_CAP) {
            let n = s.parse::&lt;u64&gt;().unwrap();
            self.merge(p, n, &amp;mut carry);
            p += 1;
        }
        while carry != 0 {
            self.merge(p, 0, &amp;mut carry);
            p += 1;
        }
    }
    fn head(&amp;self, digits: u8) -&gt; u64 {
        assert!(digits &lt;= 10);
        let mut head = 0u64;
        for p in (0..self.a.len()).rev() {
            if let Some(&amp;con) = self.a.get(p) {
                if head &gt; u64::MAX / Self::TEN_MIL {
                    break;
                }
                head *= Self::TEN_MIL;
                head += con;
            }
        }
        let display_threshold = 10u64.pow(digits as u32);
        while head &gt;= display_threshold {
            head /= 10;
        }
        head
    }
}

fn main() {
    let mut big_num = BigNum::new();
    for &amp;b in FIFTY_DIGIT_NUMBERS.iter() {
        big_num.add(b);
    }
    let ans = big_num.head(10);

    println!(&quot;{}&quot;, ans);
    assert_eq!(ans, 5537376230);

    {
        let mut a = BigNum::new();
        for &amp;b in vec![&quot;5&quot;, &quot;48&quot;, &quot;125&quot;].iter() {
            a.add(b);
        }
        assert_eq!(a.head(10), 178);
    }
    {
        let mut a = BigNum::new();
        let v = vec![
            &quot;9999999999&quot;,
            &quot;99999999999999999999&quot;,
            &quot;40005484537376233&quot;,
            &quot;3&quot;,
            &quot;5537376230&quot;,
            &quot;40000000000000&quot;
        ];
        for &amp;b in v.iter() {
            a.add(b);
        }
        assert_eq!(a.head(10), 1000400455);
    }
    {
        let mut a = BigNum::new();
        a.add(&amp;&quot;99999999999999999999&quot;);
        assert_eq!(a.head(10), 9999999999);
    }
}

const FIFTY_DIGIT_NUMBERS: [&amp;str; 100] = [
    &quot;37107287533902102798797998220837590246510135740250&quot;,
    &quot;46376937677490009712648124896970078050417018260538&quot;,
    &quot;74324986199524741059474233309513058123726617309629&quot;,
    &quot;91942213363574161572522430563301811072406154908250&quot;,
    &quot;23067588207539346171171980310421047513778063246676&quot;,
    &quot;89261670696623633820136378418383684178734361726757&quot;,
    &quot;28112879812849979408065481931592621691275889832738&quot;,
    &quot;44274228917432520321923589422876796487670272189318&quot;,
    &quot;47451445736001306439091167216856844588711603153276&quot;,
    &quot;70386486105843025439939619828917593665686757934951&quot;,
    &quot;62176457141856560629502157223196586755079324193331&quot;,
    &quot;64906352462741904929101432445813822663347944758178&quot;,
    &quot;92575867718337217661963751590579239728245598838407&quot;,
    &quot;58203565325359399008402633568948830189458628227828&quot;,
    &quot;80181199384826282014278194139940567587151170094390&quot;,
    &quot;35398664372827112653829987240784473053190104293586&quot;,
    &quot;86515506006295864861532075273371959191420517255829&quot;,
    &quot;71693888707715466499115593487603532921714970056938&quot;,
    &quot;54370070576826684624621495650076471787294438377604&quot;,
    &quot;53282654108756828443191190634694037855217779295145&quot;,
    &quot;36123272525000296071075082563815656710885258350721&quot;,
    &quot;45876576172410976447339110607218265236877223636045&quot;,
    &quot;17423706905851860660448207621209813287860733969412&quot;,
    &quot;81142660418086830619328460811191061556940512689692&quot;,
    &quot;51934325451728388641918047049293215058642563049483&quot;,
    &quot;62467221648435076201727918039944693004732956340691&quot;,
    &quot;15732444386908125794514089057706229429197107928209&quot;,
    &quot;55037687525678773091862540744969844508330393682126&quot;,
    &quot;18336384825330154686196124348767681297534375946515&quot;,
    &quot;80386287592878490201521685554828717201219257766954&quot;,
    &quot;78182833757993103614740356856449095527097864797581&quot;,
    &quot;16726320100436897842553539920931837441497806860984&quot;,
    &quot;48403098129077791799088218795327364475675590848030&quot;,
    &quot;87086987551392711854517078544161852424320693150332&quot;,
    &quot;59959406895756536782107074926966537676326235447210&quot;,
    &quot;69793950679652694742597709739166693763042633987085&quot;,
    &quot;41052684708299085211399427365734116182760315001271&quot;,
    &quot;65378607361501080857009149939512557028198746004375&quot;,
    &quot;35829035317434717326932123578154982629742552737307&quot;,
    &quot;94953759765105305946966067683156574377167401875275&quot;,
    &quot;88902802571733229619176668713819931811048770190271&quot;,
    &quot;25267680276078003013678680992525463401061632866526&quot;,
    &quot;36270218540497705585629946580636237993140746255962&quot;,
    &quot;24074486908231174977792365466257246923322810917141&quot;,
    &quot;91430288197103288597806669760892938638285025333403&quot;,
    &quot;34413065578016127815921815005561868836468420090470&quot;,
    &quot;23053081172816430487623791969842487255036638784583&quot;,
    &quot;11487696932154902810424020138335124462181441773470&quot;,
    &quot;63783299490636259666498587618221225225512486764533&quot;,
    &quot;67720186971698544312419572409913959008952310058822&quot;,
    &quot;95548255300263520781532296796249481641953868218774&quot;,
    &quot;76085327132285723110424803456124867697064507995236&quot;,
    &quot;37774242535411291684276865538926205024910326572967&quot;,
    &quot;23701913275725675285653248258265463092207058596522&quot;,
    &quot;29798860272258331913126375147341994889534765745501&quot;,
    &quot;18495701454879288984856827726077713721403798879715&quot;,
    &quot;38298203783031473527721580348144513491373226651381&quot;,
    &quot;34829543829199918180278916522431027392251122869539&quot;,
    &quot;40957953066405232632538044100059654939159879593635&quot;,
    &quot;29746152185502371307642255121183693803580388584903&quot;,
    &quot;41698116222072977186158236678424689157993532961922&quot;,
    &quot;62467957194401269043877107275048102390895523597457&quot;,
    &quot;23189706772547915061505504953922979530901129967519&quot;,
    &quot;86188088225875314529584099251203829009407770775672&quot;,
    &quot;11306739708304724483816533873502340845647058077308&quot;,
    &quot;82959174767140363198008187129011875491310547126581&quot;,
    &quot;97623331044818386269515456334926366572897563400500&quot;,
    &quot;42846280183517070527831839425882145521227251250327&quot;,
    &quot;55121603546981200581762165212827652751691296897789&quot;,
    &quot;32238195734329339946437501907836945765883352399886&quot;,
    &quot;75506164965184775180738168837861091527357929701337&quot;,
    &quot;62177842752192623401942399639168044983993173312731&quot;,
    &quot;32924185707147349566916674687634660915035914677504&quot;,
    &quot;99518671430235219628894890102423325116913619626622&quot;,
    &quot;73267460800591547471830798392868535206946944540724&quot;,
    &quot;76841822524674417161514036427982273348055556214818&quot;,
    &quot;97142617910342598647204516893989422179826088076852&quot;,
    &quot;87783646182799346313767754307809363333018982642090&quot;,
    &quot;10848802521674670883215120185883543223812876952786&quot;,
    &quot;71329612474782464538636993009049310363619763878039&quot;,
    &quot;62184073572399794223406235393808339651327408011116&quot;,
    &quot;66627891981488087797941876876144230030984490851411&quot;,
    &quot;60661826293682836764744779239180335110989069790714&quot;,
    &quot;85786944089552990653640447425576083659976645795096&quot;,
    &quot;66024396409905389607120198219976047599490197230297&quot;,
    &quot;64913982680032973156037120041377903785566085089252&quot;,
    &quot;16730939319872750275468906903707539413042652315011&quot;,
    &quot;94809377245048795150954100921645863754710598436791&quot;,
    &quot;78639167021187492431995700641917969777599028300699&quot;,
    &quot;15368713711936614952811305876380278410754449733078&quot;,
    &quot;40789923115535562561142322423255033685442488917353&quot;,
    &quot;44889911501440648020369068063960672322193204149535&quot;,
    &quot;41503128880339536053299340368006977710650566631954&quot;,
    &quot;81234880673210146739058568557934581403627822703280&quot;,
    &quot;82616570773948327592232845941706525094512325230608&quot;,
    &quot;22918802058777319719839450180888072429661980811197&quot;,
    &quot;77158542502016545090413245809786882778948721859617&quot;,
    &quot;72107838435069186155435662884062257473692284509516&quot;,
    &quot;20849603980134001723930671666823555245252804609722&quot;,
    &quot;53503534226472524250874054075591789781264330331690&quot;,
];
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vRlJuIRAfvk9blII2ifNvIHjV_cegQeQnkfxARQjpXdg7F3pvp5pZC8fIWi59jOZ_a7GDxH_bNRYswT/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">struct Position {
    initial_number: u64,
    number_of_steps: u32,
}

struct Collatz {
    init_num: u64,
    next: Option&lt;u64&gt;,
    step_accum: u32,
    cache: Vec&lt;u32&gt;,
    max: Position,
}

impl Collatz {
    fn update_records(&amp;mut self) {
        if let Some(s) = self.cache.get_mut(self.init_num as usize) {
            *s = self.step_accum;
        }
        if self.max.number_of_steps &lt; self.step_accum {
            self.max.number_of_steps = self.step_accum;
            self.max.initial_number = self.init_num;
        }
    }
    fn move_along(&amp;mut self) -&gt; Option&lt;u64&gt; {
        let n = self.next?;
        if n == 1 {
            self.step_accum += 1;
            self.next = None;
            self.update_records();
            return self.next;
        }
        match self.cache.get(n as usize) {
            Some(r) if *r != 0 =&gt; {
                self.step_accum += 1 + *r;
                self.next = None;
                self.update_records();
                return self.next;
            }
            _ =&gt; (),
        }
        if n % 2 != 0 {
            self.step_accum += 2;
            self.next = Some((3 * n + 1) / 2);
            return self.next;
        }
        self.step_accum += 1;
        self.next = Some(n / 2);
        self.next
    }
    fn init_next(&amp;mut self) {
        assert!(self.init_num &gt; 1);
        self.next = if self.init_num % 2 == 0 {
            Some(self.init_num / 2)
        } else {
            Some(3 * self.init_num + 1)
        }
    }
}

fn main() {
    let mut c = Collatz {
        init_num: 0,
        next: None,
        step_accum: 0,
        cache: vec![0; 1_000_000],
        max: Position {
            initial_number: 1,
            number_of_steps: 0,
        },
    };

    for i in 500_000..1_000_000u64 {
        c.init_num = i;
        c.init_next();
        c.step_accum = 0;
        while c.move_along().is_some() {}
    }

    println!(
        &quot;initial_number: {}, number_of_steps plus 1: {}&quot;,
        c.max.initial_number,
        c.max.number_of_steps + 1
    );
    assert_eq!(c.max.initial_number, 837799);
    assert_eq!(c.max.number_of_steps + 1, 525);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSD27mp0PbcpszSY1rHZJbt-ys8hKwcyUgZ9AneW1vmTdWXaj_JPXGZoj3Bu9IcwF_zUGunFeLjC-Ed/embed?start=false&loop=false&delayms=3000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">struct Permutation {
    numerator: u8,
    denominator: u8,
}

impl Permutation {
    fn num(&amp;self) -&gt; u128 {
        let mut acc = 1u128;
        for i in self.denominator + 1..self.numerator + 1 {
            acc *= i as u128;
        }
        acc
    }
}

struct Grid {
    width: u8,
    height: u8,
}

fn factorial(n: u8) -&gt; u128 {
    match n {
        0 | 1 =&gt; 1,
        _ =&gt; factorial(n - 1) * n as u128,
    }
}

impl Grid {
    fn routes(&amp;self) -&gt; u64 {
        let a = Permutation {
            numerator: self.width + self.height,
            denominator: self.width,
        }
        .num();
        let b = factorial(self.height);
        (a / b) as u64
    }
}

fn main() {
    let r = Grid {
        width: 20,
        height: 20,
    }
    .routes();

    println!(&quot;{}&quot;, r);
    assert_eq!(r, 137846528820);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut lattice = [[0u64; 22]; 22];
    lattice[1][1] = 1;
    for y in 1..lattice.len() {
        for x in 1..lattice.len() {
            lattice[y][x] += lattice[y - 1][x] + lattice[y][x - 1];
        }
    }
    let r = lattice[21][21];

    println!(&quot;{}&quot;, r);
    assert_eq!(r, 137846528820);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">struct Combination {
    n: f64,
    k: f64,
}

impl Combination {
    fn _num(&amp;self, n: f64, k: f64) -&gt; f64 {
        if k == 1f64 {
            return n;
        }
        if k == 0f64 {
            return 1f64;
        }
        let prev = self._num(n, k - 1f64);
        prev * (n - k + 1f64) / k
    }
    fn num(&amp;self) -&gt; f64 {
        self._num(self.n, self.k)
    }
}

struct Grid {
    width: u8,
    height: u8,
}

impl Grid {
    fn routes(&amp;self) -&gt; u64 {
        Combination{
            n: (self.width + self.height) as f64,
            k: self.width as f64,
        }
        .num().ceil() as u64
    }
}

fn main() {
    let r = Grid {
        width: 20,
        height: 20,
    }
    .routes();

    println!(&quot;{}&quot;, r);
    assert_eq!(r, 137846528820);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">struct Combination {
    n: f64,
    k: f64,
}

impl Combination {
    fn num(&amp;self) -&gt; f64 {
        assert!(self.n == 2f64 * self.k);
        (1..=self.k as isize)
            .map(|x| x as f64)
            .map(|x| (self.k + x) / x)
            .product::&lt;f64&gt;()
    }
}

struct Grid {
    width: u8,
    height: u8,
}

impl Grid {
    fn routes(&amp;self) -&gt; u64 {
        Combination{
            n: (self.width + self.height) as f64,
            k: self.width as f64,
        }
        .num().ceil() as u64
    }
}

fn main() {
    let r = Grid {
        width: 20,
        height: 20,
    }
    .routes();

    println!(&quot;{}&quot;, r);
    assert_eq!(r, 137846528820);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">struct PermutationWithRepetition {
    numerator: u8,
    denominator: Vec&lt;u8&gt;,
    _numerator_elem: Vec&lt;u8&gt;,
    _denominator_elem: Vec&lt;u8&gt;,
}

impl Default for PermutationWithRepetition {
    fn default() -&gt; PermutationWithRepetition {
        PermutationWithRepetition {
            numerator: 0,
            denominator: vec![],
            _numerator_elem: vec![],
            _denominator_elem: vec![],
        }
    }
}

impl PermutationWithRepetition {
    fn reduce(&amp;mut self) {
        if let Some(d0) = self.denominator.pop() {
            for i in d0..self.numerator {
                self._numerator_elem.push(i + 1);
            }
        }
        for &amp;d in self.denominator.iter() {
            for i in 2..=d {
                self._denominator_elem.push(i);
            }
        }
    }
    fn num(&amp;mut self) -&gt; u64 {
        let mut denom_elem_shrink: Vec&lt;u8&gt; = vec![];
        let mut prod = 1u64;
        for n0 in &amp;self._numerator_elem {
            prod *= *n0 as u64;
            if let Some(d0) = self._denominator_elem.pop() {
                if prod % d0 as u64 == 0 {
                    prod /= d0 as u64;
                    continue;
                }
                denom_elem_shrink.push(d0);
            }
        }
        denom_elem_shrink.append(&amp;mut self._denominator_elem);
        let prod_deno: u64 = denom_elem_shrink.iter().map(|&amp;v| v as u64).product();
        prod / prod_deno
    }
}

struct Grid {
    width: u8,
    height: u8,
}

impl Grid {
    fn routes(&amp;self) -&gt; u64 {
        let mut p = PermutationWithRepetition {
            numerator: self.width + self.height,
            denominator: vec![self.width, self.height],
            ..Default::default()
        };
        p.reduce();
        p.num()
    }
}

fn main() {
    let r = Grid {
        width: 20,
        height: 20,
    }
    .routes();

    println!(&quot;{}&quot;, r);
    assert_eq!(r, 137846528820);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSLA9mFUfTAx0ZsejwWuZPyTcsMwYAOkHJ_Bl1QM-KA4S4InTRvwmr0vqcm0f6Bk8uAQ5feb2GIRPDv/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e13.html">Q.13. Large sum</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct BigNum {
    v: Vec&lt;u64&gt;,
}

impl BigNum {
    const TEN_MIL: u64 = 10_000_000_000;
    fn double(&amp;mut self) {
        let mut carry = 0u64;
        for con in self.v.iter_mut() {
            *con *= 2;
            *con += carry;
            if *con &lt; Self::TEN_MIL {
                carry = 0;
                continue;
            }
            carry = 1;
            *con -= Self::TEN_MIL;
        }
        if carry != 0 {
            self.v.push(1u64);
        }
    }
    fn sum_of_digits(&amp;self) -&gt; u32 {
        let mut sum = 0u32;
        for &amp;con in &amp;self.v {
            let mut t = con;
            while t &gt; 0 {
                sum += (t % 10) as u32;
                t /= 10;
            }
        }
        sum
    }
}

fn main() {
    let mut n = BigNum { v: vec![1] };
    for _ in 0..1000 {
        n.double();
    }
    let ans = n.sum_of_digits();

    println!(&quot;{}&quot;, ans);
    assert_eq!(ans, 1366);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQdYhmZ7heCpVxLZB-8ITBfWPbC88rVQ4QVFaZxRDSnN0eqx2Jn-y6e5yMihOfqKmVS2T7dy1JKxJNl/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">const ZERO_TO_19: [&amp;str; 20] = [
    &quot;&quot;,
    &quot;one&quot;,
    &quot;two&quot;,
    &quot;three&quot;,
    &quot;four&quot;,
    &quot;five&quot;,
    &quot;six&quot;,
    &quot;seven&quot;,
    &quot;eight&quot;,
    &quot;nine&quot;,
    &quot;ten&quot;,
    &quot;eleven&quot;,
    &quot;twelve&quot;,
    &quot;thirteen&quot;,
    &quot;fourteen&quot;,
    &quot;fifteen&quot;,
    &quot;sixteen&quot;,
    &quot;seventeen&quot;,
    &quot;eighteen&quot;,
    &quot;nineteen&quot;,
];

const ZERO_TO_90: [&amp;str; 10] = [
    &quot;&quot;, &quot;&quot;, &quot;twenty&quot;, &quot;thirty&quot;, &quot;forty&quot;, &quot;fifty&quot;, &quot;sixty&quot;, &quot;seventy&quot;, &quot;eighty&quot;, &quot;ninety&quot;,
];

fn count_words(i: usize) -&gt; u32 {
    match i {
        0..=19 =&gt; ZERO_TO_19[i].len() as u32,
        20..=99 =&gt; {
            let p1 = i % 10;
            let p2 = i / 10;
            (ZERO_TO_90[p2].len() + ZERO_TO_19[p1].len()) as u32
        }
        _ if i % 100 == 0 &amp;&amp; i != 1000 =&gt; {
            let d = i / 100;
            (ZERO_TO_19[d].len() + &quot;hundred&quot;.len()) as u32
        }
        101..=999 =&gt; {
            let p3 = i / 100;
            let p2p1 = i - p3 * 100;
            (ZERO_TO_19[p3].len() + &quot;hundredand&quot;.len()) as u32 + count_words(p2p1)
        }
        1000 =&gt; (&quot;onethousand&quot;.len()) as u32,
        _ =&gt; 0,
    }
}

fn main() {
    let mut sum = 0u32;
    for i in 1..=1000 {
        sum += count_words(i);
    }

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 21124);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSXQXOHGlkvP-KTjoOesbw0ATJ6Bia-C5dngFiGl77htYuuV_WMHANOgVkxynxPWBVvWCKipyiQMD35/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut triangle: Vec&lt;Vec&lt;u16&gt;&gt; = vec![
        vec![75],
        vec![95, 64],
        vec![17, 47, 82],
        vec![18, 35, 87, 10],
        vec![20, 4, 82, 47, 65],
        vec![19, 1, 23, 75, 3, 34],
        vec![88, 2, 77, 73, 7, 63, 67],
        vec![99, 65, 4, 28, 6, 16, 70, 92],
        vec![41, 41, 26, 56, 83, 40, 80, 70, 33],
        vec![41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
        vec![53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
        vec![70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
        vec![91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
        vec![63, 66, 4, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
        vec![4, 62, 98, 27, 23, 9, 70, 98, 73, 93, 38, 53, 60, 4, 23],
    ];
    triangle.push(vec![0; triangle.last().unwrap().len() + 1]);
    for y in (0..triangle.len() - 1).rev() {
        for x in 0..triangle[y].len() {
            let a = triangle[y + 1][x];
            let b = triangle[y + 1][x + 1];
            triangle[y][x] += std::cmp::max(a, b);
        }
    }
    let sum = triangle[0][0];

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 1074);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSqetvNUMza7dxjmu3c00GpZU6zxBjSed22EWzCeH4raDgUznelHgnRjhM4yqPj6Bva6m_ti8MHlTGg/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">fn length_of_february(year: u16) -&gt; u8 {
    if (year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0 {
        29
    } else {
        28
    }
}

struct FirstDayOfMonth {
    year: u16,
    month: u8,
    day_count: u64,
    sunday_count: u32,
}

impl FirstDayOfMonth {
    fn new() -&gt; Self {
        Self {
            year: 1900,
            month: 1,
            day_count: 0,
            sunday_count: 0,
        }
    }
    fn is_sunday(&amp;self) -&gt; bool {
        self.day_count % 7 == 6
    }
    fn next_month(&amp;mut self) {
        self.day_count += match self.month {
            2 =&gt; length_of_february(self.year) as u64,
            4 | 6 | 9 | 11 =&gt; 30,
            _ =&gt; 31,
        };
        if self.month == 12 {
            self.year += 1;
            self.month = 1;
        } else {
            self.month += 1;
        }
        if self.year != 1900 &amp;&amp; self.is_sunday() {
            self.sunday_count += 1;
        }
    }
}

fn main() {
    let mut cal = FirstDayOfMonth::new();
    while !(cal.year == 2000 &amp;&amp; cal.month == 12) {
        cal.next_month();
    }
    let sum = cal.sunday_count;

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 171);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">#[derive(PartialEq)]
enum Weekday {
    Mon,
    Tue,
    Wed,
    Thu,
    Fri,
    Sat,
    Sun,
}

fn zeller_congruence(mut y: u32, mut m: u32, d: u32) -&gt; Weekday {
    if m == 1 || m == 2 {
        m += 12;
        y -= 1;
    }
    let yd = y / 100;
    let ym = y % 100;
    match (d + (26 * (m + 1)) / 10 + ym + ym / 4 + yd / 4 + 5 * yd) % 7 {
        0 =&gt; Weekday::Sat,
        1 =&gt; Weekday::Sun,
        2 =&gt; Weekday::Mon,
        3 =&gt; Weekday::Tue,
        4 =&gt; Weekday::Wed,
        5 =&gt; Weekday::Thu,
        6 =&gt; Weekday::Fri,
        _ =&gt; panic!(),
    }
}

fn main() {
    let mut sum = 0u32;
    for y in 1901u32..=2000 {
        for m in 1u32..=12 {
            let weekday = zeller_congruence(y, m, 1);
            if weekday == Weekday::Sun {
                sum += 1;
            }
        }
    }

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 171);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTuzRkU6jBYqeyGIJRL9jwFyEHzgK8XBwfZcvoLEWXlw2aD20lgvYoDWN4Y_6-RLE81wq_SsrG7IIGO/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e13.html">Q.13 Large sum</a></li>
<li><a href="./e16.html">Q.16 Power digit sum</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct BigNum {
    v: Vec&lt;u64&gt;,
}

impl BigNum {
    const TEN_MIL: u64 = 10_000_000_000;
    fn factorial(&amp;mut self) {
        assert!(self.v.len() == 1);
        let up = self.v[0];
        assert!(((u64::MAX as f32 - Self::TEN_MIL as f32) / Self::TEN_MIL as f32) &gt; (up as f32));
        for b in 2..up {
            self._multiply(b);
        }
    }
    fn _multiply(&amp;mut self, b: u64) {
        let mut carry = 0u64;
        for con in self.v.iter_mut() {
            *con *= b;
            *con += carry;
            if *con &lt; Self::TEN_MIL {
                carry = 0;
                continue;
            }
            carry = *con / Self::TEN_MIL;
            *con -= carry * Self::TEN_MIL;
        }
        if carry != 0 {
            self.v.push(carry);
        }
    }
    fn sum_of_digits(&amp;self) -&gt; u32 {
        let mut sum = 0u32;
        for &amp;con in &amp;self.v {
            let mut t = con;
            while t &gt; 0 {
                sum += (t % 10) as u32;
                t /= 10;
            }
        }
        sum
    }
}

fn main() {
    let mut a = BigNum { v: vec![100u64] };
    a.factorial();
    let sum = a.sum_of_digits();

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 648);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTx7-dkY4_Fyf5yNk070DTNnSuvFBIlqMwyQ9a4uwRcALH2UrtUevfvY0aouIPuk1bog2PGtOQ5Tqpt/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e12.html">Q.12 Highly divisible triangular number</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct AmicableNumberScanner {
    below: u32,
    _primes: Vec&lt;u32&gt;,
    _aliquot_sum: Vec&lt;u32&gt;,
}

impl AmicableNumberScanner {
    fn new(below: u32) -&gt; Self {
        Self {
            below: below,
            _primes: vec![2, 3],
            _aliquot_sum: vec![0u32; below as usize],
        }
    }
    fn _divide_fully(&amp;self, n: &amp;mut u32, d: u32, side: &amp;mut u32, sum: &amp;mut u32) {
        if *n % d != 0 {
            return;
        }
        let mut exp = 0u32;
        while {
            *n /= d;
            exp += 1;
            *n % d == 0
        } {}
        *side = (*n as f32).sqrt() as u32;
        *sum *= (d.pow(exp + 1) - 1) / (d - 1);
    }
    fn _sum_of_divisors(&amp;mut self, mut n: u32) -&gt; u32 {
        let mut side = (n as f32).sqrt() as u32;
        let mut sum = 1u32;
        for &amp;p in self._primes.iter() {
            if p &gt; side || n == 1 {
                break;
            }
            self._divide_fully(&amp;mut n, p, &amp;mut side, &amp;mut sum);
        }
        if n != 1 {
            sum *= (n * n - 1) / (n - 1);
            self._primes.push(n);
        }
        sum
    }
    fn pair_sum(&amp;mut self) -&gt; u32 {
        for n in 4..self.below {
            self._aliquot_sum[n as usize] = self._sum_of_divisors(n) - n;
        }
        let mut sum = 0u32;
        for (i, v) in self._aliquot_sum.iter().enumerate() {
            let vsize = *v as usize;
            if vsize &gt;= self._aliquot_sum.len() {
                continue;
            }
            if vsize == i {
                continue;
            }
            if self._aliquot_sum[vsize] == i as u32 {
                sum += *v;
            }
        }
        sum
    }
}

fn main() {
    let sum = AmicableNumberScanner::new(10_000).pair_sum();

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 31626);
}
</code></pre></pre>
<hr />
<ul>
<li><a href="./e10.html">Q.10 Summation of primes</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct Index {
    i: usize,
    _ite: Box&lt;dyn Iterator&lt;Item = usize&gt;&gt;,
}

impl Index {
    fn increment(&amp;mut self) {
        self.i += self._ite.next().unwrap();
    }
    fn new() -&gt; Self {
        Self {
            i: 5,
            _ite: Box::new(vec![2usize, 4].into_iter().cycle()),
        }
    }
}

fn rule_out(sieve: &amp;mut Vec&lt;bool&gt;, prime: usize) {
    for i in (prime * prime..sieve.len()).step_by(prime) {
        sieve[i] = false;
    }
}

fn primes(below: u32) -&gt; Vec&lt;u32&gt; {
    let mut primes: Vec&lt;u32&gt; = vec![2u32, 3u32];
    let mut sieve = vec![true; below as usize];
    let sqrt = (sieve.len() as f32).sqrt() as usize;
    let mut index = Index::new();
    while index.i &lt;= sqrt {
        if sieve[index.i] {
            primes.push(index.i as u32);
            rule_out(&amp;mut sieve, index.i);
        }
        index.increment();
    }
    while index.i &lt; sieve.len() {
        if sieve[index.i] {
            primes.push(index.i as u32);
        }
        index.increment();
    }
    primes
}

struct AmicableNumberScanner {
    below: u32,
    _primes: Vec&lt;u32&gt;,
    _checked: Vec&lt;bool&gt;,
}

impl AmicableNumberScanner {
    fn new(below: u32) -&gt; Self {
        Self {
            below: below,
            _primes: primes(below),
            _checked: vec![false; below as usize],
        }
    }
    fn _divide_fully(&amp;self, n: &amp;mut u32, d: u32, side: &amp;mut u32, sum: &amp;mut u32) {
        if *n % d != 0 {
            return;
        }
        let mut exp = 0u32;
        while {
            *n /= d;
            exp += 1;
            *n % d == 0
        } {}
        *side = (*n as f32).sqrt() as u32;
        *sum *= (d.pow(exp + 1) - 1) / (d - 1);
    }
    fn _sum_of_divisors(&amp;mut self, mut n: u32) -&gt; u32 {
        let mut side = (n as f32).sqrt() as u32;
        let mut sum = 1u32;
        for &amp;p in self._primes.iter() {
            if p &gt; side || n == 1 {
                break;
            }
            self._divide_fully(&amp;mut n, p, &amp;mut side, &amp;mut sum);
        }
        if n != 1 {
            sum *= (n * n - 1) / (n - 1);
        }
        sum
    }
    fn pair_sum(&amp;mut self) -&gt; u32 {
        let mut pair_sum = 0u32;
        for a in 4..self.below {
            if self._checked[a as usize] {
                continue;
            }
            let sum = self._sum_of_divisors(a) - a;
            if sum &lt;= a {
                continue;
            }
            if sum &gt;= self.below {
                continue;
            }
            let b = self._sum_of_divisors(sum) - sum;
            self._checked[sum as usize] = true;
            if a == b {
                pair_sum += a + sum;
            }
        }
        pair_sum
    }
}

fn main() {
    let sum = AmicableNumberScanner::new(10_000).pair_sum();

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 31626);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vStc3yljpxd5sfgEk-ArIhJFDLxVJham5kt16FnLCrlxS0-6RKTLO-aacD6WrxPyR26UO8S_tdfpteF/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PL2_aWCzGMAwKedT2KfDMB9YA5DgASZb3U">mycodeschool - Sorting Algorithms, youtube playlist</a></li>
</ul>
<p>Because the original name list is very long, these examples have only a part of it.</p>
<ul>
<li><a href="e22.html#quick">1. Go to Quick sort</a></li>
<li><a href="e22.html#merge">2. Go to Merge sort</a></li>
<li><a href="e22.html#heap">3. Go to Heap sort</a></li>
<li><a href="e22.html#bubble">4. Go to Bubble sort</a></li>
<li><a href="e22.html#selection">5. Go to Selection sort</a></li>
<li><a href="e22.html#insertion">6. Go to Insertion sort</a></li>
</ul>
<p><a name="quick"><h2 id="1-quick-sort"><a class="header" href="#1-quick-sort">1. Quick sort</a></h2></a></p>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/XE4VP_8Y0BU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<pre><pre class="playground"><code class="language-rust editable">fn median&lt;'a&gt;(vec: &amp;[&amp;'a str], a: usize, c: usize) -&gt; &amp;'a str {
    let b = (c - a) / 2;
    let (astr, bstr, cstr) = (vec[a], vec[b], vec[c]);
    if (cstr &lt; astr &amp;&amp; astr &lt; bstr) || (bstr &lt;= astr &amp;&amp; astr &lt; cstr) {
        astr
    } else if (astr &lt; bstr &amp;&amp; bstr &lt; cstr) || (cstr &lt; bstr &amp;&amp; bstr &lt;= astr) {
        bstr
    } else {
        cstr
    }
}

fn met(sinker_depth: usize, float_depth: usize) -&gt; bool {
    sinker_depth &gt;= float_depth
}

fn sink_fully(vec: &amp;[&amp;str], depth: &amp;mut usize, blocker: &amp;str) {
    while vec[*depth] &lt; blocker {
        *depth += 1;
    }
}

fn float_fully(vec: &amp;[&amp;str], depth: &amp;mut usize, blocker: &amp;str) {
    while vec[*depth] &gt; blocker {
        *depth -= 1;
    }
}

fn break_through(vec: &amp;mut [&amp;str], sinker_depth: &amp;mut usize, float_depth: &amp;mut usize) {
    vec.swap(*sinker_depth, *float_depth);
    *sinker_depth += 1;
    *float_depth -= 1;
}

fn release(vec: &amp;mut [&amp;str], sinker0: usize, float0: usize) {
    if met(sinker0, float0) {
        return;
    }
    match float0 - sinker0 {
        1 =&gt; {
            if vec[sinker0] &gt; vec[sinker0 + 1] {
                vec.swap(sinker0, sinker0 + 1);
            }
            return;
        }
        2 =&gt; {
            if vec[sinker0] &gt; vec[sinker0 + 1] {
                vec.swap(sinker0, sinker0 + 1);
            }
            if vec[sinker0 + 1] &gt; vec[sinker0 + 2] {
                vec.swap(sinker0 + 1, sinker0 + 2);
            }
            if vec[sinker0] &gt; vec[sinker0 + 1] {
                vec.swap(sinker0, sinker0 + 1);
            }
            return;
        }
        _ =&gt; (),
    }
    let pivot = median(vec, sinker0, float0);
    let mut sinker = sinker0;
    let mut float = float0;
    loop {
        sink_fully(vec, &amp;mut sinker, pivot);
        float_fully(vec, &amp;mut float, pivot);
        if met(sinker, float) {
            break;
        }
        break_through(vec, &amp;mut sinker, &amp;mut float);
    }
    println!(&quot;pivot: {}&quot;, pivot);
    println!(&quot;{:#?}&quot;, &amp;vec[sinker0..=sinker - 1]);
    println!(&quot;{:#?}&quot;, &amp;vec[float + 1..=float0]);
    release(vec, sinker0, sinker - 1);
    release(vec, float + 1, float0);
}

fn quick_sort(vec: &amp;mut [&amp;str]) {
    release(vec, 0, vec.len() - 1);
}

fn name_score(index: usize, name: &amp;str) -&gt; u32 {
    let position = index as u32 + 1;
    let worth = name.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::&lt;u32&gt;();
    position * worth
}

fn main() {
    let mut names = NAMES.to_vec();
    quick_sort(&amp;mut names);
    let sum: u32 = names
        .iter()
        .enumerate()
        .map(|(i, &amp;n)| name_score(i, n))
        .sum();

    println!(&quot;---\n{:#?}&quot;, names);
    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 26578);
}

const NAMES: &amp;[&amp;str] = &amp;[
    &quot;MARY&quot;,
    &quot;PATRICIA&quot;,
    &quot;LINDA&quot;,
    &quot;BARBARA&quot;,
    &quot;ELIZABETH&quot;,
    &quot;JENNIFER&quot;,
    &quot;MARIA&quot;,
    &quot;SUSAN&quot;,
    &quot;MARGARET&quot;,
    &quot;DOROTHY&quot;,
    &quot;LISA&quot;,
    &quot;NANCY&quot;,
    &quot;KAREN&quot;,
    &quot;BETTY&quot;,
    &quot;HELEN&quot;,
    &quot;SANDRA&quot;,
    &quot;DONNA&quot;,
    &quot;CAROL&quot;,
    &quot;RUTH&quot;,
    &quot;SHARON&quot;,
    &quot;MICHELLE&quot;,
    &quot;LAURA&quot;,
    &quot;SARAH&quot;,
    &quot;KIMBERLY&quot;,
    &quot;DEBORAH&quot;,
    &quot;JESSICA&quot;,
    &quot;SHIRLEY&quot;,
    &quot;CYNTHIA&quot;,
];
</code></pre></pre>
<hr />
<ul>
<li><a href="e22.html#quick">1. Go to Quick sort</a></li>
<li><a href="e22.html#merge">2. Go to Merge sort</a></li>
<li><a href="e22.html#heap">3. Go to Heap sort</a></li>
<li><a href="e22.html#bubble">4. Go to Bubble sort</a></li>
<li><a href="e22.html#selection">5. Go to Selection sort</a></li>
<li><a href="e22.html#insertion">6. Go to Insertion sort</a></li>
</ul>
<p><a name="merge"><h2 id="2-merge-sort"><a class="header" href="#2-merge-sort">2. Merge sort</a></h2></a></p>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/gR6nycuZKlM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<pre><pre class="playground"><code class="language-rust editable">fn drain_into&lt;'a&gt;(a: &amp;[&amp;'a str], b: &amp;[&amp;'a str], ab: &amp;mut [&amp;'a str]) {
    let (mut x, mut y, mut i) = (0, 0, 0);
    while x &lt; a.len() &amp;&amp; y &lt; b.len() {
        if a[x] &lt; b[y] {
            ab[i] = a[x];
            x += 1;
        } else {
            ab[i] = b[y];
            y += 1;
        }
        i += 1;
    }
    if x &lt; a.len() {
        ab[i..].copy_from_slice(&amp;a[x..]);
    }
    if y &lt; b.len() {
        ab[i..].copy_from_slice(&amp;b[y..]);
    }
}

fn merge_sort(segment: &amp;mut [&amp;str]) {
    let n = segment.len();
    let m = n / 2;
    if n &lt;= 1 {
        return;
    }
    merge_sort(&amp;mut segment[0..m]);
    merge_sort(&amp;mut segment[m..n]);
    println!(&quot;---\n{:#?}&quot;, &amp;segment[0..m]);
    println!(&quot;{:#?}&quot;, &amp;segment[m..n]);

    let mut tmp: Vec&lt;&amp;str&gt; = segment.to_vec();
    drain_into(&amp;segment[0..m], &amp;segment[m..n], &amp;mut tmp[..]);
    segment.copy_from_slice(&amp;tmp);
    println!(&quot;{:#?}&quot;, &amp;segment);
}

fn name_score(index: usize, name: &amp;str) -&gt; u32 {
    let position = index as u32 + 1;
    let worth = name.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::&lt;u32&gt;();
    position * worth
}

fn main() {
    let mut names = NAMES.to_vec();
    merge_sort(&amp;mut names);
    let sum: u32 = names
        .iter()
        .enumerate()
        .map(|(i, &amp;n)| name_score(i, n))
        .sum();

    println!(&quot;---\n{:#?}&quot;, names);
    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 26578);
}

const NAMES: &amp;[&amp;str] = &amp;[
    &quot;MARY&quot;,
    &quot;PATRICIA&quot;,
    &quot;LINDA&quot;,
    &quot;BARBARA&quot;,
    &quot;ELIZABETH&quot;,
    &quot;JENNIFER&quot;,
    &quot;MARIA&quot;,
    &quot;SUSAN&quot;,
    &quot;MARGARET&quot;,
    &quot;DOROTHY&quot;,
    &quot;LISA&quot;,
    &quot;NANCY&quot;,
    &quot;KAREN&quot;,
    &quot;BETTY&quot;,
    &quot;HELEN&quot;,
    &quot;SANDRA&quot;,
    &quot;DONNA&quot;,
    &quot;CAROL&quot;,
    &quot;RUTH&quot;,
    &quot;SHARON&quot;,
    &quot;MICHELLE&quot;,
    &quot;LAURA&quot;,
    &quot;SARAH&quot;,
    &quot;KIMBERLY&quot;,
    &quot;DEBORAH&quot;,
    &quot;JESSICA&quot;,
    &quot;SHIRLEY&quot;,
    &quot;CYNTHIA&quot;,
];
</code></pre></pre>
<hr />
<ul>
<li><a href="e22.html#quick">1. Go to Quick sort</a></li>
<li><a href="e22.html#merge">2. Go to Merge sort</a></li>
<li><a href="e22.html#heap">3. Go to Heap sort</a></li>
<li><a href="e22.html#bubble">4. Go to Bubble sort</a></li>
<li><a href="e22.html#selection">5. Go to Selection sort</a></li>
<li><a href="e22.html#insertion">6. Go to Insertion sort</a></li>
</ul>
<p><a name="heap"><h2 id="3-heap-sort"><a class="header" href="#3-heap-sort">3. Heap sort</a></h2></a></p>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/3DYIgTC4T1o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<pre><pre class="playground"><code class="language-rust editable">fn heapify(arr: &amp;mut [&amp;str], pi: usize) {
    let lef = 2 * pi + 1;
    let rig = lef + 1;
    if lef &gt;= arr.len() {
        return;
    }
    let max = if rig &gt;= arr.len() {
        lef
    } else if arr[lef] &gt;= arr[rig] {
        lef
    } else {
        rig
    };
    if arr[pi] &lt; arr[max] {
        arr.swap(pi, max);
        println!(&quot;---\n     {}&quot;, &amp;arr[pi]);
        println!(&quot;{}/\\{}&quot;, &amp;arr.get(lef).unwrap_or(&amp;&quot;{}&quot;), &amp;arr.get(rig).unwrap_or(&amp;&quot;{}&quot;));
        heapify(arr, max);
    }
}

fn build_heap(arr: &amp;mut [&amp;str]) {
    let parental_indice = 0..arr.len() / 2;
    for pi in parental_indice.rev() {
        heapify(arr, pi);
    }
}

fn serialize(arr: &amp;mut [&amp;str]) {
    for edge in (1..arr.len()).rev() {
        arr.swap(0, edge);
        println!(&quot;---\n{:#?}&quot;, &amp;arr[edge..]);
        heapify(&amp;mut arr[..edge], 0);
    }
}

fn heap_sort(arr: &amp;mut [&amp;str]) {
    build_heap(arr);
    print_heap(arr);
    serialize(arr);
}

fn name_score(index: usize, name: &amp;str) -&gt; u32 {
    let position = index as u32 + 1;
    let worth = name.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::&lt;u32&gt;();
    position * worth
}

fn main() {
    let mut names = NAMES.to_vec();
    heap_sort(&amp;mut names);
    let sum: u32 = names
        .iter()
        .enumerate()
        .map(|(i, &amp;n)| name_score(i, n))
        .sum();

    println!(&quot;---\n{:#?}&quot;, names);
    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 26578);
}

const NAMES: &amp;[&amp;str] = &amp;[
    &quot;MARY&quot;,
    &quot;PATRICIA&quot;,
    &quot;LINDA&quot;,
    &quot;BARBARA&quot;,
    &quot;ELIZABETH&quot;,
    &quot;JENNIFER&quot;,
    &quot;MARIA&quot;,
    &quot;SUSAN&quot;,
    &quot;MARGARET&quot;,
    &quot;DOROTHY&quot;,
    &quot;LISA&quot;,
    &quot;NANCY&quot;,
    &quot;KAREN&quot;,
    &quot;BETTY&quot;,
    &quot;HELEN&quot;,
    &quot;SANDRA&quot;,
    &quot;DONNA&quot;,
    &quot;CAROL&quot;,
    &quot;RUTH&quot;,
    &quot;SHARON&quot;,
    &quot;MICHELLE&quot;,
    &quot;LAURA&quot;,
    &quot;SARAH&quot;,
    &quot;KIMBERLY&quot;,
    &quot;DEBORAH&quot;,
    &quot;JESSICA&quot;,
    &quot;SHIRLEY&quot;,
    &quot;CYNTHIA&quot;,
];

fn print_heap(arr: &amp;[&amp;str]) {
    fn print_white_space(n: usize) {
        for _ in 0..n {
            print!(&quot; &quot;);
        }
    }
    let height = ((arr.len() + 1) as f32).log2() as usize + 1;
    let cell = arr
        .iter()
        .map(|&amp;s| s.len())
        .reduce(|a, b| std::cmp::max(a, b))
        .unwrap();
    let width = cell * 2usize.pow(height as u32);
    let mut levels: Vec&lt;Vec&lt;String&gt;&gt; = vec![vec![]; height + 1];

    for (i, &amp;v) in arr.iter().enumerate() {
        let h = ((i + 1) as f32).log2() as usize + 1;
        let r = levels.get_mut(h).unwrap();
        r.push(format!(&quot;{}({})&quot;, v, i));
    }
    let last = levels.last_mut().unwrap();
    while last.len() &lt; 2usize.pow(height as u32 - 1) {
        last.push(String::new());
    }
    for r in levels {
        if r.len() == 0 {
            continue;
        }
        let space = (width) / r.len();
        print_white_space(space / 2);
        for (i, c) in r.iter().enumerate() {
            let arrow1 = if i % 2 == 0 { &quot;&quot; } else { &quot;\\&quot; };
            let arrow2 = if i % 2 != 0 { &quot;&quot; } else { &quot;/&quot; };
            print!(&quot;{}{}{}&quot;, arrow1, c, arrow2);
            print_white_space(space - c.len() - 1);
        }
        println!()
    }
}
</code></pre></pre>
<hr />
<ul>
<li><a href="e22.html#quick">1. Go to Quick sort</a></li>
<li><a href="e22.html#merge">2. Go to Merge sort</a></li>
<li><a href="e22.html#heap">3. Go to Heap sort</a></li>
<li><a href="e22.html#bubble">4. Go to Bubble sort</a></li>
<li><a href="e22.html#selection">5. Go to Selection sort</a></li>
<li><a href="e22.html#insertion">6. Go to Insertion sort</a></li>
</ul>
<p><a name="bubble"><h2 id="4-bubble-sort"><a class="header" href="#4-bubble-sort">4. Bubble sort</a></h2></a></p>
<pre><pre class="playground"><code class="language-rust editable">fn bubble_sort(vec: &amp;mut Vec&lt;&amp;str&gt;) {
    for i in 0..vec.len() {
        let mut swap_was_required = false;
        for j in 0..vec.len() - i - 1 {
            if vec[j] &gt; vec[j + 1] {
                vec.swap(j, j + 1);
                swap_was_required = true;
            }
        }
        println!(&quot;---\n{:#?}&quot;, &amp;vec[0..vec.len() - i - 1]);
        println!(&quot;{:#?}&quot;, &amp;vec[vec.len() - i - 1..vec.len()]);
        if !swap_was_required {
            break;
        }
    }
}

fn name_score(index: usize, name: &amp;str) -&gt; u32 {
    let position = index as u32 + 1;
    let worth = name.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::&lt;u32&gt;();
    position * worth
}

fn main() {
    let mut names = NAMES.to_vec();
    bubble_sort(&amp;mut names);
    let sum: u32 = names
        .iter()
        .enumerate()
        .map(|(i, &amp;n)| name_score(i, n))
        .sum();

    println!(&quot;---\n{:#?}&quot;, names);
    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 26578);
}

const NAMES: &amp;[&amp;str] = &amp;[
    &quot;MARY&quot;,
    &quot;PATRICIA&quot;,
    &quot;LINDA&quot;,
    &quot;BARBARA&quot;,
    &quot;ELIZABETH&quot;,
    &quot;JENNIFER&quot;,
    &quot;MARIA&quot;,
    &quot;SUSAN&quot;,
    &quot;MARGARET&quot;,
    &quot;DOROTHY&quot;,
    &quot;LISA&quot;,
    &quot;NANCY&quot;,
    &quot;KAREN&quot;,
    &quot;BETTY&quot;,
    &quot;HELEN&quot;,
    &quot;SANDRA&quot;,
    &quot;DONNA&quot;,
    &quot;CAROL&quot;,
    &quot;RUTH&quot;,
    &quot;SHARON&quot;,
    &quot;MICHELLE&quot;,
    &quot;LAURA&quot;,
    &quot;SARAH&quot;,
    &quot;KIMBERLY&quot;,
    &quot;DEBORAH&quot;,
    &quot;JESSICA&quot;,
    &quot;SHIRLEY&quot;,
    &quot;CYNTHIA&quot;,
];
</code></pre></pre>
<hr />
<ul>
<li><a href="e22.html#quick">1. Go to Quick sort</a></li>
<li><a href="e22.html#merge">2. Go to Merge sort</a></li>
<li><a href="e22.html#heap">3. Go to Heap sort</a></li>
<li><a href="e22.html#bubble">4. Go to Bubble sort</a></li>
<li><a href="e22.html#selection">5. Go to Selection sort</a></li>
<li><a href="e22.html#insertion">6. Go to Insertion sort</a></li>
</ul>
<p><a name="selection"><h2 id="5-selection-sort"><a class="header" href="#5-selection-sort">5. Selection sort</a></h2></a></p>
<pre><pre class="playground"><code class="language-rust editable">fn selection_sort(vec: &amp;mut Vec&lt;&amp;str&gt;) {
    for i in 0..vec.len() {
        let mut min_index = i;
        for j in (i + 1)..vec.len() {
            if vec[j] &lt; vec[min_index] {
                min_index = j;
            }
        }
        vec.swap(i, min_index);
        println!(&quot;---\n{:#?}&quot;, &amp;vec[0..=i]);
        println!(&quot;{:#?}&quot;, &amp;vec[std::cmp::min(i + 1, vec.len())..vec.len()]);
    }
}

fn name_score(index: usize, name: &amp;str) -&gt; u32 {
    let position = index as u32 + 1;
    let worth = name.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::&lt;u32&gt;();
    position * worth
}

fn main() {
    let mut names = NAMES.to_vec();
    selection_sort(&amp;mut names);
    let sum: u32 = names
        .iter()
        .enumerate()
        .map(|(i, &amp;n)| name_score(i, n))
        .sum();

    println!(&quot;---\n{:#?}&quot;, names);
    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 26578);
}

const NAMES: &amp;[&amp;str] = &amp;[
    &quot;MARY&quot;,
    &quot;PATRICIA&quot;,
    &quot;LINDA&quot;,
    &quot;BARBARA&quot;,
    &quot;ELIZABETH&quot;,
    &quot;JENNIFER&quot;,
    &quot;MARIA&quot;,
    &quot;SUSAN&quot;,
    &quot;MARGARET&quot;,
    &quot;DOROTHY&quot;,
    &quot;LISA&quot;,
    &quot;NANCY&quot;,
    &quot;KAREN&quot;,
    &quot;BETTY&quot;,
    &quot;HELEN&quot;,
    &quot;SANDRA&quot;,
    &quot;DONNA&quot;,
    &quot;CAROL&quot;,
    &quot;RUTH&quot;,
    &quot;SHARON&quot;,
    &quot;MICHELLE&quot;,
    &quot;LAURA&quot;,
    &quot;SARAH&quot;,
    &quot;KIMBERLY&quot;,
    &quot;DEBORAH&quot;,
    &quot;JESSICA&quot;,
    &quot;SHIRLEY&quot;,
    &quot;CYNTHIA&quot;,
];
</code></pre></pre>
<hr />
<ul>
<li><a href="e22.html#quick">1. Go to Quick sort</a></li>
<li><a href="e22.html#merge">2. Go to Merge sort</a></li>
<li><a href="e22.html#heap">3. Go to Heap sort</a></li>
<li><a href="e22.html#bubble">4. Go to Bubble sort</a></li>
<li><a href="e22.html#selection">5. Go to Selection sort</a></li>
<li><a href="e22.html#insertion">6. Go to Insertion sort</a></li>
</ul>
<p><a name="insertion"><h2 id="6-insertion-sort"><a class="header" href="#6-insertion-sort">6. Insertion sort</a></h2></a></p>
<pre><pre class="playground"><code class="language-rust editable">fn insertion_sort(vec: &amp;mut [&amp;str]) {
    for i in 0..vec.len() {
        for j in (0..i).rev() {
            if vec[j] &lt; vec[j + 1] {
                break;
            }
            vec.swap(j, j + 1);
        }
        println!(&quot;---\n{:#?}&quot;, &amp;vec[0..=i]);
        println!(&quot;{:#?}&quot;, &amp;vec[i + 1..vec.len()]);
    }
}

fn name_score(index: usize, name: &amp;str) -&gt; u32 {
    let position = index as u32 + 1;
    let worth = name.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::&lt;u32&gt;();
    position * worth
}

fn main() {
    let mut names = NAMES.to_vec();
    insertion_sort(&amp;mut names);
    let sum: u32 = names
        .iter()
        .enumerate()
        .map(|(i, &amp;n)| name_score(i, n))
        .sum();

    println!(&quot;---\n{:#?}&quot;, names);
    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 26578);
}

const NAMES: &amp;[&amp;str] = &amp;[
    &quot;MARY&quot;,
    &quot;PATRICIA&quot;,
    &quot;LINDA&quot;,
    &quot;BARBARA&quot;,
    &quot;ELIZABETH&quot;,
    &quot;JENNIFER&quot;,
    &quot;MARIA&quot;,
    &quot;SUSAN&quot;,
    &quot;MARGARET&quot;,
    &quot;DOROTHY&quot;,
    &quot;LISA&quot;,
    &quot;NANCY&quot;,
    &quot;KAREN&quot;,
    &quot;BETTY&quot;,
    &quot;HELEN&quot;,
    &quot;SANDRA&quot;,
    &quot;DONNA&quot;,
    &quot;CAROL&quot;,
    &quot;RUTH&quot;,
    &quot;SHARON&quot;,
    &quot;MICHELLE&quot;,
    &quot;LAURA&quot;,
    &quot;SARAH&quot;,
    &quot;KIMBERLY&quot;,
    &quot;DEBORAH&quot;,
    &quot;JESSICA&quot;,
    &quot;SHIRLEY&quot;,
    &quot;CYNTHIA&quot;,
];
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSJWw9sxGTBWSwo48Whs-A9PsPpJbGzZjcOqk3VG0LOoHhGn43XN0lTcAgUu2Ht__sLJFrv9XnLo5KU/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e21.html">Q.21 Amicable numbers</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct Index {
    i: usize,
    _ite: Box&lt;dyn Iterator&lt;Item = usize&gt;&gt;,
}

impl Index {
    fn increment(&amp;mut self) {
        self.i += self._ite.next().unwrap();
    }
    fn new() -&gt; Self {
        Self {
            i: 5,
            _ite: Box::new(vec![2usize, 4].into_iter().cycle()),
        }
    }
}

fn rule_out(sieve: &amp;mut Vec&lt;bool&gt;, prime: usize) {
    for i in (prime * prime..sieve.len()).step_by(prime) {
        sieve[i] = false;
    }
}

fn primes(below: u32) -&gt; Vec&lt;u32&gt; {
    let mut primes: Vec&lt;u32&gt; = vec![2u32, 3u32];
    let mut sieve = vec![true; below as usize];
    let sqrt = (sieve.len() as f32).sqrt() as usize;
    let mut index = Index::new();
    while index.i &lt;= sqrt {
        if sieve[index.i] {
            primes.push(index.i as u32);
            rule_out(&amp;mut sieve, index.i);
        }
        index.increment();
    }
    while index.i &lt; sieve.len() {
        if sieve[index.i] {
            primes.push(index.i as u32);
        }
        index.increment();
    }
    primes
}

struct AbundantNumberScanner {
    below: u32,
    _primes: Vec&lt;u32&gt;,
    _pair_sieve: Vec&lt;bool&gt;,
}

impl AbundantNumberScanner {
    fn new(below: u32) -&gt; Self {
        Self {
            below: below,
            _primes: primes(below),
            _pair_sieve: vec![false; below as usize],
        }
    }
    fn _divide_fully(&amp;self, n: &amp;mut u32, d: u32, side: &amp;mut u32, sum: &amp;mut u32) {
        if *n % d != 0 {
            return;
        }
        let mut exp = 0u32;
        while {
            *n /= d;
            exp += 1;
            *n % d == 0
        } {}
        *side = (*n as f32).sqrt() as u32;
        *sum *= (d.pow(exp + 1) - 1) / (d - 1);
    }
    fn _sum_of_divisors(&amp;mut self, mut n: u32) -&gt; u32 {
        let mut side = (n as f32).sqrt() as u32;
        let mut sum = 1u32;
        for &amp;p in self._primes.iter() {
            if p &gt; side || n == 1 {
                break;
            }
            self._divide_fully(&amp;mut n, p, &amp;mut side, &amp;mut sum);
        }
        if n != 1 {
            sum *= (n * n - 1) / (n - 1);
        }
        sum
    }
    fn init_abundant_num_pair_sieve(&amp;mut self) {
        let mut abundant_numbers = vec![];
        for n in 12..self.below {
            let sum = self._sum_of_divisors(n) - n;
            if sum &gt; n {
                abundant_numbers.push(n);
            }
        }
        for (i, &amp;a) in abundant_numbers.iter().enumerate() {
            for &amp;b in abundant_numbers[i..].iter() {
                if let Some(n) = self._pair_sieve.get_mut((a + b) as usize) {
                    *n = true;
                }
            }
        }
    }
    fn non_pair_sum(&amp;mut self) -&gt; u32 {
        let mut non_pair_sum = 0u32;
        for n in 1..self.below {
            if !self._pair_sieve[n as usize] {
                non_pair_sum += n;
            }
        }
        non_pair_sum
    }
}

fn main() {
    let mut a = AbundantNumberScanner::new(28_124);
    a.init_abundant_num_pair_sieve();
    let sum = a.non_pair_sum();

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 4179871);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTRCk13zsn15xDyEFwVuQt7hA8gtwjOUsSsYvIgsQeNSlzOiwTp6lGAUwcpFxVF4s5ZDtVa3B_3wu0s/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">fn factorial(n: u64) -&gt; u64 {
    match n {
        0 | 1 =&gt; 1,
        _ =&gt; factorial(n - 1) * n,
    }
}

fn main() {
    let mut reminder = 1_000_000u64 - 1;
    let mut items_with_order = vec![0u64, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    let mut millionth_element = 0u64;
    for weight in (0..items_with_order.len()).rev() {
        let unit = factorial(weight as u64);
        let quot = reminder / unit;
        reminder -= quot * unit;
        millionth_element *= 10;
        millionth_element += items_with_order.remove(quot as usize);
    }

    println!(&quot;{}&quot;, millionth_element);
    assert_eq!(millionth_element, 2783915460);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vR2gB5wBnYUkJZkOlkIoW89riXWHCkPTJN8RpNy0UlUyG1XBAa4z9Pa8WTN9pYL1MWrnijESPRqd77h/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let constant_1 = (1f64 + 5f64.sqrt()).log10() - 2f64.log10();
    let constant_2 = 5f64.log10() / 2f64;
    let digits_of_nth_fibonacci = |nth: f64| -&gt; f64 { nth * constant_1 - constant_2 };

    let ratio = (1f64 + 5f64.sqrt()) / 2f64;
    let iteration = 10f64.log(ratio);
    let estimation = iteration * 999f64;
    println!(&quot;estimation: {} th Fibonacci number would have 1000 digits&quot;, estimation);
    let mut n = (estimation - iteration).floor(); // rollback to 999 digits
    assert!(digits_of_nth_fibonacci(n) &lt; 999f64);
    while digits_of_nth_fibonacci(n) &lt; 999f64 {
        n += 1f64;
    }

    println!(&quot;{}&quot;, n);
    assert_eq!(n as u32, 4782);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vRMiD__hYXG8wlxsWSnlO9B1TUosCb0623nX6z-GucRUBS06Oswkvc5kx_MkIYeRdP5n1B63A0-p3JA/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="e26.html#long-division">1. Go to a solution using the long division</a></li>
<li><a href="e26.html#prime">2. Go to a solution using prime numbers</a></li>
<li><a href="e26.html#mod-pow">3. Go to a solution using the mod_pow function against the divisors of p-1</a></li>
<li><a href="e26.html#ref">4. Go to reference</a></li>
</ul>
<p><a name="long-division"><h2 id="1-long-division"><a class="header" href="#1-long-division">1. Long division</a></h2></a></p>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/rVhU8Vyhz7c" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<html><iframe frameborder="0" width="750" height="600" src="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20divisor%20%3D%204999%3B%0A%20%20%20%20let%20mut%20dividend%20%3D%201%3B%0A%20%20%20%20let%20mut%20dividend_logs%20%3D%20vec!%5B%5D%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20dividend%20%25%3D%20divisor%3B%0A%20%20%20%20%20%20%20%20if%20dividend%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20if%20dividend_logs.contains(%26dividend)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20position%20%3D%20dividend_logs%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20.iter()%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20.position(%7C%26v%7C%20v%20%3D%3D%20dividend)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20.unwrap()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20recurring_cycle%20%3D%20dividend_logs.len()%20-%20position%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22reciprocal%3A%20%7B%7D%2C%20repeating%20digits%3A%20%7B%7D%2C%20repeats%20with%3A%20%7B%7D%5Cn%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20dividend%20logs%3A%20%7B%3A%3F%7D%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20divisor%2C%20recurring_cycle%2C%20dividend%2C%20dividend_logs%0A%20%20%20%20%20%20%20%20%20%20%20%20)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20dividend_logs.push(dividend)%3B%0A%20%20%20%20%20%20%20%20dividend%20*%3D%2010%3B%0A%20%20%20%20%7D%0A%7D%0A"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">struct UnitFraction {
    reciprocal: u32,
    repetend_length: u32,
}

fn is_recurring(mut n: u32) -&gt; bool {
    if n % 2 != 0 &amp;&amp; n % 5 != 0 {
        return true;
    }
    for &amp;d in [2u32, 5].iter() {
        while n % d == 0 {
            n /= d;
        }
        if n == 1 {
            return false;
        }
    }
    true
}

fn repetend_length(n: u32, residue_history: &amp;mut [u32]) -&gt; u32 {
    assert!(residue_history.len() &gt;= n as usize);
    let mut dividend = 1u32;
    for nth_time_around in 0u32.. {
        let residue = dividend % n;
        let last_time = residue_history[residue as usize];
        if last_time != 0 {
            return nth_time_around - last_time;
        }
        residue_history[residue as usize] = nth_time_around;
        dividend = residue * 10;
    }
    panic!(&quot;irrational number&quot;)
}

fn number_with_longest_recurring_cycle(below: u32) -&gt; u32 {
    assert!(below &gt; 3);
    let mut uf = UnitFraction {
        reciprocal: 1,
        repetend_length: 0,
    };
    let blank = vec![0u32; below as usize];
    let mut residue_history = vec![0u32; below as usize];
    for n in (1u32..below).rev() {
        if !is_recurring(n) {
            continue;
        }
        residue_history[..n as usize].copy_from_slice(&amp;blank[..n as usize]);
        let length = repetend_length(n, &amp;mut residue_history[0..n as usize]);
        if n - 1 == length {
            return n;
        }
        if length &gt; uf.repetend_length {
            uf.repetend_length = length;
            uf.reciprocal = n;
        }
    }
    uf.reciprocal
}

fn main() {
    let num = number_with_longest_recurring_cycle(1000);
    println!(&quot;{}&quot;, num);
    assert_eq!(num, 983);

    assert_eq!(number_with_longest_recurring_cycle(10000), 9967);
    assert_eq!(number_with_longest_recurring_cycle(9968), 9967);
    assert_eq!(number_with_longest_recurring_cycle(5000), 4967);
    assert_eq!(number_with_longest_recurring_cycle(8), 7);
    assert_eq!(number_with_longest_recurring_cycle(20), 19);
    assert_eq!(number_with_longest_recurring_cycle(18), 17);
    assert_eq!(number_with_longest_recurring_cycle(25), 23);
    assert_eq!(number_with_longest_recurring_cycle(6), 3);
}
</code></pre></pre>
<hr />
<ul>
<li><a href="e26.html#long-division">1. Go to a solution using the long division</a></li>
<li><a href="e26.html#prime">2. Go to a solution using prime numbers</a></li>
<li><a href="e26.html#mod-pow">3. Go to a solution using the mod_pow function against the divisors of p-1</a></li>
<li><a href="e26.html#ref">4. Go to reference</a></li>
</ul>
<p><a name="prime"><h2 id="2-prime-numbers"><a class="header" href="#2-prime-numbers">2. Prime numbers</a></h2></a></p>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/jbiaz_aHHUQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<html><iframe frameborder="0" width="750" height="600" src="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20n%20%3D%204999%3B%0A%20%20%20%20if%20is_prime(n)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20is%20a%20prime%22%2C%20n)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20is%20not%20a%20prime%22%2C%20n)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20is_prime(n%3A%20u64)%20-%3E%20bool%20%7B%0A%20%20%20%20if%20n%20%3C%202%20%7B%0A%20%20%20%20%20%20%20%20return%20false%3B%0A%20%20%20%20%7D%0A%20%20%20%20if%20n%20%3D%3D%202%20%7C%7C%20n%20%3D%3D%203%20%7C%7C%20n%20%3D%3D%205%20%7B%0A%20%20%20%20%20%20%20%20return%20true%3B%0A%20%20%20%20%7D%0A%20%20%20%20for%20d%20in%20%26%5B2u64%2C%203%2C%205%5D%20%7B%0A%20%20%20%20%20%20%20%20if%20n%20%25%20*d%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20false%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20let%20side%20%3D%20(n%20as%20f64).sqrt()%20as%20u64%3B%0A%20%20%20%20let%20mut%20d%20%3D%205u64%3B%0A%20%20%20%20for%20i%20in%20%5B2u64%2C%204%5D.iter().cycle()%20%7B%0A%20%20%20%20%20%20%20%20if%20d%20%3E%20side%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20d%20%2B%3D%20*i%3B%0A%20%20%20%20%20%20%20%20if%20n%20%25%20d%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20false%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20true%0A%7D%0A"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">struct Index {
    i: usize,
    _ite: Box&lt;dyn Iterator&lt;Item = usize&gt;&gt;,
}

impl Index {
    fn increment(&amp;mut self) {
        self.i += self._ite.next().unwrap();
    }
    fn new() -&gt; Self {
        Self {
            i: 5,
            _ite: Box::new(vec![2usize, 4].into_iter().cycle()),
        }
    }
}

fn rule_out(sieve: &amp;mut Vec&lt;bool&gt;, prime: usize) {
    for i in (prime * prime..sieve.len()).step_by(prime) {
        sieve[i] = false;
    }
}

fn primes(below: u32) -&gt; Vec&lt;u32&gt; {
    let mut primes: Vec&lt;u32&gt; = vec![2u32, 3u32];
    let mut sieve = vec![true; below as usize];
    let sqrt = (sieve.len() as f32).sqrt() as usize;
    let mut index = Index::new();
    while index.i &lt;= sqrt {
        if sieve[index.i] {
            primes.push(index.i as u32);
            rule_out(&amp;mut sieve, index.i);
        }
        index.increment();
    }
    while index.i &lt; sieve.len() {
        if sieve[index.i] {
            primes.push(index.i as u32);
        }
        index.increment();
    }
    primes
}

fn repetend_length(n: u32) -&gt; u32 {
    assert!(n % 2 != 0 &amp;&amp; n % 5 != 0);
    let mut dividend = 10u32;
    for nth_time_around in 1u32.. {
        let residue = dividend % n;
        if residue == 1 {
            return nth_time_around
        }
        dividend = residue * 10;
    }
    panic!(&quot;irrational number&quot;)
}

fn number_with_longest_recurring_cycle(below: u32) -&gt; u32 {
    if below &lt; 7 {
        return 3;
    }
    let primes = primes(below);
    for &amp;p in primes.iter().rev() {
        if repetend_length(p) == p - 1 {
            return p;
        }
    }
    panic!(&quot;couldn't find a point that n - 1 == repetend_length(n)&quot;)
}

fn main() {
    let num = number_with_longest_recurring_cycle(1000);
    println!(&quot;{}&quot;, num);
    assert_eq!(num, 983);

    assert_eq!(number_with_longest_recurring_cycle(10000), 9967);
    assert_eq!(number_with_longest_recurring_cycle(9968), 9967);
    assert_eq!(number_with_longest_recurring_cycle(5000), 4967);
    assert_eq!(number_with_longest_recurring_cycle(8), 7);
    assert_eq!(number_with_longest_recurring_cycle(20), 19);
    assert_eq!(number_with_longest_recurring_cycle(18), 17);
    assert_eq!(number_with_longest_recurring_cycle(25), 23);
    assert_eq!(number_with_longest_recurring_cycle(6), 3);
}
</code></pre></pre>
<hr />
<ul>
<li><a href="e26.html#long-division">1. Go to a solution using the long division</a></li>
<li><a href="e26.html#prime">2. Go to a solution using prime numbers</a></li>
<li><a href="e26.html#mod-pow">3. Go to a solution using the mod_pow function against the divisors of p-1</a></li>
<li><a href="e26.html#ref">4. Go to reference</a></li>
</ul>
<p><a name="mod-pow"><h2 id="3-divisors-of-p-1-and-modular-exponentiation"><a class="header" href="#3-divisors-of-p-1-and-modular-exponentiation">3. Divisors of p-1 and modular exponentiation</a></h2></a></p>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/L-Wzglnm4dM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<html><iframe frameborder="0" width="750" height="600" src="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20n%20%3D%209966%3B%0A%20%20%20%20let%20divisors%20%3D%20list_divisors(n)%3B%0A%20%20%20%20println!(%22divisors%20of%20%7B%7D%3A%20%7B%3A%3F%7D%22%2C%20n%2C%20divisors)%3B%0A%7D%0A%0Afn%20list_divisors(n%3A%20u32)%20-%3E%20Vec%3Cu32%3E%20%7B%0A%20%20%20%20let%20side%20%3D%20(n%20as%20f32).sqrt()%20as%20u32%3B%0A%20%20%20%20let%20mut%20vec%20%3D%20vec!%5B%5D%3B%0A%20%20%20%20for%20d%20in%201..%3Dside%20%7B%0A%20%20%20%20%20%20%20%20if%20n%20%25%20d%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20vec.push(d)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20d%20!%3D%20side%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20vec.push(n%20%2F%20d)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20vec.sort()%3B%0A%20%20%20%20vec%0A%7D"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">struct Index {
    i: usize,
    _ite: Box&lt;dyn Iterator&lt;Item = usize&gt;&gt;,
}

impl Index {
    fn increment(&amp;mut self) {
        self.i += self._ite.next().unwrap();
    }
    fn new() -&gt; Self {
        Self {
            i: 5,
            _ite: Box::new(vec![2usize, 4].into_iter().cycle()),
        }
    }
}

fn rule_out(sieve: &amp;mut Vec&lt;bool&gt;, prime: usize) {
    for i in (prime * prime..sieve.len()).step_by(prime) {
        sieve[i] = false;
    }
}

fn primes(below: u32) -&gt; Vec&lt;u32&gt; {
    let mut primes: Vec&lt;u32&gt; = vec![2u32, 3u32];
    let mut sieve = vec![true; below as usize];
    let sqrt = (sieve.len() as f32).sqrt() as usize;
    let mut index = Index::new();
    while index.i &lt;= sqrt {
        if sieve[index.i] {
            primes.push(index.i as u32);
            rule_out(&amp;mut sieve, index.i);
        }
        index.increment();
    }
    while index.i &lt; sieve.len() {
        if sieve[index.i] {
            primes.push(index.i as u32);
        }
        index.increment();
    }
    primes
}

fn mod_pow(mut a: u32, mut exp: u32, m: u32) -&gt; u32 {
    if m == 1 {
        return 0;
    }
    if exp == 0 {
        return 1;
    }
    let mut result = 1;
    a %= m;
    loop {
        if exp % 2 == 1 {
            result *= a;
            result %= m;
        }
        exp &gt;&gt;= 1;
        if exp == 0 {
            break;
        }
        a *= a;
        a %= m;
    }
    result
}

fn list_divisors(n: u32) -&gt; Vec&lt;u32&gt; {
    let side = (n as f32).sqrt() as u32;
    let mut vec = vec![];
    for d in 1..=side {
        if n % d == 0 {
            vec.push(d);
            if d != side {
                vec.push(n / d);
            }
        }
    }
    vec.sort();
    vec
}

fn number_with_longest_recurring_cycle(below: u32) -&gt; u32 {
    if below &lt; 7 {
        return 3;
    }
    let primes = primes(below);
    'next_prime: for &amp;p in primes.iter().rev() {
        let divisors = list_divisors(p - 1);
        for &amp;d in &amp;divisors[0..divisors.len() - 1] {
            if mod_pow(10, d, p) == 1 {
                continue 'next_prime;
            }
        }
        return p;
    }
    panic!(&quot;couldn't find a point that n - 1 == recurring_length(n)&quot;)
}

fn main() {
    let num = number_with_longest_recurring_cycle(1000);
    println!(&quot;{}&quot;, num);
    assert_eq!(num, 983);

    assert_eq!(number_with_longest_recurring_cycle(10000), 9967);
    assert_eq!(number_with_longest_recurring_cycle(9968), 9967);
    assert_eq!(number_with_longest_recurring_cycle(5000), 4967);
    assert_eq!(number_with_longest_recurring_cycle(8), 7);
    assert_eq!(number_with_longest_recurring_cycle(20), 19);
    assert_eq!(number_with_longest_recurring_cycle(18), 17);
    assert_eq!(number_with_longest_recurring_cycle(25), 23);
    assert_eq!(number_with_longest_recurring_cycle(6), 3);
}
</code></pre></pre>
<ul>
<li><a href="e26.html#long-division">1. Go to a solution using the long division</a></li>
<li><a href="e26.html#prime">2. Go to a solution using prime numbers</a></li>
<li><a href="e26.html#mod-pow">3. Go to a solution using the mod_pow function against the divisors of p-1</a></li>
<li><a href="e26.html#ref">4. Go to reference</a></li>
</ul>
<p><a name="ref"><h2 id="reference"><a class="header" href="#reference">Reference</a></h2></a></p>
<ul>
<li><a href="https://oeis.org/A001913">A001913 Full reptend primes: primes with primitive root 10.</a></li>
<li><a href="https://oeis.org/A007732">A007732 Period of decimal representation of 1/n.</a></li>
<li><a href="./e21.html">Q.21 Amicable numbers</a></li>
<li><a href="./e2.html">Q.2 Even Fibonacci numbers</a></li>
<li><a href="https://www.youtube.com/watch?v=_9fbBSxhkuA">Youtube, Fermat’s HUGE little theorem, pseudoprimes and Futurama</a></li>
<li><a href="https://www.youtube.com/watch?v=HvMSRWTE2mI">Youtube, Fool-Proof Test for Primes - Numberphile</a></li>
<li><a href="https://blog.dreamshire.com/solutions/project_euler/project-euler-problem-026-solution/">Project Euler &amp; HackerRank Problem 26 Solution</a></li>
<li><a href="https://cp-algorithms.com/algebra/binary-exp.html#toc-tgt-3">Binary Exponentiation - CP-Algorithms</a></li>
</ul>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vRJsGmSGhPtXL0TgyTirOVGVib758YiXCVOGy3OK5Clq4KJmHZJhj8I611KgkLaVYN8aa8ZrtifrH90/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">struct Sieve {
    _sieve: Vec&lt;bool&gt;,
}

impl Sieve {
    fn rule_out(&amp;mut self, prime: usize) {
        for i in (prime * prime..self._sieve.len()).step_by(prime) {
            self._sieve[i] = false;
        }
    }
    fn init(&amp;mut self) {
        let sqrt = (self._sieve.len() as f64).sqrt() as usize;
        let mut index = 5usize;
        for &amp;i in [2usize, 4].iter().cycle() {
            if index &gt; sqrt {
                break;
            }
            if self._sieve[index] {
                self.rule_out(index);
            }
            index += i;
        }
    }
    fn new(below: u32) -&gt; Self {
        assert!(below &gt; 4);
        let sieve = vec![true; below as usize];
        let mut s = Self { _sieve: sieve };
        s.init();
        s
    }
    fn is_prime(&amp;self, n: u32) -&gt; bool {
        assert!(n &lt; self._sieve.len() as u32);
        if n == 2 || n == 3 {
            return true;
        }
        if n == 0 || n == 1 || n % 2 == 0 || n % 3 == 0 {
            return false;
        }
        self._sieve[n as usize]
    }
    fn primes(&amp;self, below: u32) -&gt; Vec&lt;u32&gt; {
        let mut primes: Vec&lt;u32&gt; = vec![2u32, 3u32];
        let mut index = 5usize;
        for &amp;i in [2usize, 4].iter().cycle() {
            if index &gt;= below as usize {
                break;
            }
            if self._sieve[index] {
                primes.push(index as u32);
            }
            index += i;
        }
        primes
    }
}

fn quadratic_formula(n: u32, a: i32, b: u32) -&gt; i32 {
    (n * n) as i32 + a * n as i32 + b as i32
}

fn main() {
    let (mut nmax, mut amax, mut bmax) = (1u32, 0i32, 0u32);
    let sieve = Sieve::new(2_000_000);
    for b in sieve.primes(1001) {
        for a in (-(b as i32) + 1)..=999 {
            let mut n = 1;
            let mut v = quadratic_formula(1, a, b);
            if !(v &gt; 1 &amp;&amp; sieve.is_prime(v as u32)) {
                continue;
            }
            while {
                n += 1;
                v = quadratic_formula(n, a, b);
                v &gt; 1 &amp;&amp; sieve.is_prime(v as u32)
            } {}
            if n &gt; nmax {
                nmax = n;
                amax = a;
                bmax = b;
            }
        }
    }
    let product = amax * bmax as i32;

    println!(&quot;{}&quot;, product);
    assert_eq!(product, -59231);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vR2w_lw9yEUy3Nq_WdzOBuntYUcmbKuZv-s7RIadF7GqDdrWhB-OY43wvGu1JXwS5gCm6EAeRX_jKJN/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e6.html">Q.6 Sum square difference</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let width = 1001u64;
    assert!(width % 2 == 1);
    let n = width / 2;
    let sum = 16 * n * (n + 1) * (2 * n + 1) / 6 + 4 * n * (1 + n) / 2 + 4 * n + 1;
    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 669171001);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTKR04aDWsJQgRSIzoEJlLqIZB90EseogdKLAD-7s34_uF8Q38hrSbJlchogh11DdKGDEQ8PC8iwJ1O/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e21.html">Q.21 Amicable numbers</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct Index {
    i: usize,
    _ite: Box&lt;dyn Iterator&lt;Item = usize&gt;&gt;,
}

impl Index {
    fn increment(&amp;mut self) {
        self.i += self._ite.next().unwrap();
    }
    fn new() -&gt; Self {
        Self {
            i: 5,
            _ite: Box::new(vec![2usize, 4].into_iter().cycle()),
        }
    }
}

fn rule_out(sieve: &amp;mut Vec&lt;bool&gt;, prime: usize) {
    for i in (prime * prime..sieve.len()).step_by(prime) {
        sieve[i] = false;
    }
}

fn primes(below: u32) -&gt; Vec&lt;u32&gt; {
    let mut primes: Vec&lt;u32&gt; = vec![2u32, 3u32];
    let mut sieve = vec![true; below as usize];
    let sqrt = (sieve.len() as f32).sqrt() as usize;
    let mut index = Index::new();
    while index.i &lt;= sqrt {
        if sieve[index.i] {
            primes.push(index.i as u32);
            rule_out(&amp;mut sieve, index.i);
        }
        index.increment();
    }
    while index.i &lt; sieve.len() {
        if sieve[index.i] {
            primes.push(index.i as u32);
        }
        index.increment();
    }
    primes
}

#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Debug)]
struct Factor {
    prime: u32,
    exp: u32,
}

fn divide_fully(n: &amp;mut u32, d: u32, side: &amp;mut u32, factors: &amp;mut Vec&lt;Factor&gt;) {
    if *n % d != 0 {
        return;
    }
    let mut exp = 0u32;
    while {
        *n /= d;
        exp += 1;
        *n % d == 0
    } {}
    factors.push(Factor { prime: d, exp: exp });
    *side = (*n as f32).sqrt() as u32;
}

fn factorize(mut n: u32, primes: &amp;[u32]) -&gt; Vec&lt;Factor&gt; {
    let mut factors = vec![];
    let mut side = (n as f32).sqrt() as u32;
    for &amp;p in primes.iter() {
        if p &gt; side || n == 1 {
            break;
        }
        divide_fully(&amp;mut n, p, &amp;mut side, &amp;mut factors);
    }
    if n != 1 {
        factors.push(Factor { prime: n, exp: 1 });
    }
    factors
}

fn count_duplication(arr: &amp;mut [Vec&lt;Factor&gt;]) -&gt; u32 {
    arr.sort();
    let mut dup = 0u32;
    for i in 1..arr.len() {
        if arr[i - 1] == arr[i] {
            dup += 1;
        }
    }
    dup
}

fn main() {
    let primes = primes(101);
    let mut expressions = Vec::new();
    (2..=100u32).map(|a| factorize(a, &amp;primes)).for_each(|a| {
        for b in 2..=100u32 {
            let mut ab = a.to_vec();
            ab.iter_mut().for_each(|f| f.exp *= b);
            expressions.push(ab);
        }
    });
    let c = expressions.len() as u32 - count_duplication(&amp;mut expressions);

    println!(&quot;{}&quot;, c);
    assert_eq!(c, 9183);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vRoiWWblcSHsZfzlRjD8JN9zSxxlT7YkOgkrY06vvNEkkwsxw3YHISIR7ioJsQfNgzC-Yl-6DVieOVN/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<html><iframe frameborder="0" width="750" height="600" src="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20power_digit_sum(mut%20n%3A%20u32%2C%20exp%3A%20u32)%20-%3E%20u32%20%7B%0A%20%20%20%20let%20mut%20sum%20%3D%200u32%3B%0A%20%20%20%20while%20n%20%3E%200%20%7B%0A%20%20%20%20%20%20%20%20let%20d%20%3D%20n%20%25%2010%3B%0A%20%20%20%20%20%20%20%20n%20%2F%3D%2010%3B%0A%20%20%20%20%20%20%20%20sum%20%2B%3D%20d.pow(exp)%3B%0A%20%20%20%20%7D%0A%20%20%20%20sum%0A%7D%0A%0Afn%20power_digit_sum_mod(n%3A%20u32%2C%20exp%3A%20u32)%20-%3E%20u32%20%7B%0A%20%20%20%20let%20log10%20%3D%20(n%20as%20f32).log10()%20as%20u32%3B%0A%20%20%20%20(0..%3Dlog10)%0A%20%20%20%20%20%20%20%20.map(%7Ci%7C%2010u32.pow(i))%0A%20%20%20%20%20%20%20%20.map(%7Cp%7C%20((n%20%25%20(p%20*%2010)%20-%20n%20%25%20p)%20%2F%20p).pow(exp))%0A%20%20%20%20%20%20%20%20.sum()%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20power_digit_sum(1634%2C%204))%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20power_digit_sum_mod(1634%2C%204))%3B%0A%7D%0A"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">fn match_pow_sum(target: u32, pow_sum_999_fold: &amp;[u32; 999]) -&gt; bool {
    let mut digits = target;
    let mut sum = 0;
    while digits &gt; 0 {
        let d = digits % 1000;
        digits /= 1000;
        if d == 0 {
            continue;
        }
        sum += pow_sum_999_fold[d as usize - 1];
        if sum &gt; target {
            return false;
        }
    }
    sum == target
}

fn pow_sum_999_fold(power_ninefold: &amp;[u32; 9]) -&gt; [u32; 999] {
    let mut pow_sum_999_fold = [0u32; 999];
    for i in 1..=pow_sum_999_fold.len() {
        let mut sum = 0;
        let mut digits = i as u32;
        while digits &gt; 0 {
            let d = digits % 10;
            digits /= 10;
            if d != 0 {
                sum += power_ninefold[d as usize - 1];
            }
        }
        pow_sum_999_fold[i - 1] = sum;
    }
    pow_sum_999_fold
}

fn digit_range_max(powed_nine: u32) -&gt; u32 {
    let mut digit_min = 1u32;
    let mut pow_sum_max = powed_nine;
    while digit_min &lt; pow_sum_max {
        digit_min *= 10;
        pow_sum_max += powed_nine;
    }
    pow_sum_max - powed_nine
}

fn main() {
    let e = 5;
    let mut power_ninefold = [0u32; 9];
    (1..=9u32).for_each(|n| power_ninefold[n as usize - 1] = n.pow(e));
    let pow_sum_999_fold = pow_sum_999_fold(&amp;power_ninefold);
    let digits_max = digit_range_max(power_ninefold[8]);
    let sum = (2..=digits_max)
        .filter(|&amp;d| match_pow_sum(d, &amp;pow_sum_999_fold))
        .sum::&lt;u32&gt;();

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 443839);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSyWfyHO_sc3vOAf6jxDtUG5NCCgX-P4lTYKM8x16aNOFpU7kOC4ZJX-I5iw3NXY8EmeE4F0AEdDnu3/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<html><iframe frameborder="0" width="750" height="600" src="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20assert_eq!(combination(8%2C%20%26%5B1%2C%203%2C%205%2C%207%5D)%2C%206)%3B%0A%20%20%20%20assert_eq!(combination(3%2C%20%26%5B1%2C%202%5D)%2C%202)%3B%0A%20%20%20%20assert_eq!(combination(2%2C%20%26%5B1%2C%202%5D)%2C%202)%3B%0A%20%20%20%20assert_eq!(combination(1%2C%20%26%5B1%2C%202%5D)%2C%201)%3B%0A%20%20%20%20assert_eq!(combination(5%2C%20%26%5B2%2C%203%5D)%2C%201)%3B%0A%20%20%20%20assert_eq!(combination(5%2C%20%26%5B1%2C%202%2C%203%5D)%2C%205)%3B%0A%20%20%20%20assert_eq!(combination(5%2C%20%26%5B1%5D)%2C%201)%3B%0A%20%20%20%20assert_eq!(combination(2%2C%20%26%5B3%5D)%2C%200)%3B%0A%7D%0A%0Afn%20combination(payment%3A%20usize%2C%20coins%3A%20%26%5Busize%5D)%20-%3E%20usize%20%7B%0A%20%20%20%20assert!(payment%20%3E%200)%3B%0A%20%20%20%20println!(%22Payment%20of%20%7B%7D%20with%20coins%20%7B%3A%3F%7D%22%2C%20payment%2C%20%26coins)%3B%0A%20%20%20%20let%20mut%20c%20%3D%200usize%3B%0A%20%20%20%20next_coin(payment%2C%20%26coins%2C%20String%3A%3Anew()%2C%20%26mut%20c)%3B%0A%20%20%20%20println!(%22Number%20of%20combinations%3A%20%7B%7D%5Cn%22%2C%20c)%3B%0A%20%20%20%20c%0A%7D%0A%0Afn%20next_coin(payment%3A%20usize%2C%20coins%3A%20%26%5Busize%5D%2C%20path%3A%20String%2C%20comb%3A%20%26mut%20usize)%20%7B%0A%20%20%20%20if%20let%20Some(co)%20%3D%20coins.first()%20%7B%0A%20%20%20%20%20%20%20%20dig(payment%2C%20*co%2C%20%26coins%5B1..%5D%2C%20path%2C%20comb)%3B%0A%20%20%20%20%7D%20else%20if%20payment%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20%7C%22%2C%20path)%3B%0A%20%20%20%20%20%20%20%20*comb%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20dig(payment%3A%20usize%2C%20co%3A%20usize%2C%20coins%3A%20%26%5Busize%5D%2C%20path%3A%20String%2C%20comb%3A%20%26mut%20usize)%20%7B%0A%20%20%20%20let%20num%20%3D%20payment%20%2F%20co%3B%0A%20%20%20%20for%20n%20in%200..%3Dnum%20%7B%0A%20%20%20%20%20%20%20%20let%20mut%20path%20%3D%20path.clone()%3B%0A%20%20%20%20%20%20%20%20if%20n%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20path.push_str(%22%7C%20%20%20%20%20%20%20%20%20%20%20%22)%3B%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20path.push_str(format!(%22%7C%20%7B%3A4%7Dx%7B%3A4%7D%20%22%2C%20n%2C%20co).as_str())%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20next_coin(payment%20-%20co%20*%20n%2C%20coins%2C%20path%2C%20comb)%3B%0A%20%20%20%20%7D%0A%7D%0A"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">use std::cmp::Ordering;

fn coin_change_combination(payment: usize, coins: &amp;[usize]) -&gt; u32 {
    assert!(payment &gt; 0 &amp;&amp; coins.len() &gt; 0);
    let mut table = vec![vec![0u32; payment]; coins.len()];
    for c in 0..table.len() {
        for p in 0..table[c].len() {
            let v_no = if c == 0 { 0u32 } else { table[c - 1][p] };
            let v_we = match (p + 1).partial_cmp(&amp;(coins[c])).expect(&quot;NaNs&quot;) {
                Ordering::Less =&gt; 0u32,
                Ordering::Equal =&gt; 1u32,
                Ordering::Greater =&gt; table[c][p - coins[c]],
            };
            table[c][p] = v_no + v_we;
        }
    }
    table[coins.len() - 1][payment - 1]
}

fn main() {
    let payment = 200usize;
    let coins = [1usize, 2, 5, 10, 20, 50, 100, 200];
    let comb = coin_change_combination(payment, &amp;coins);

    println!(&quot;{}&quot;, comb);
    assert_eq!(comb, 73682);
    assert_eq!(coin_change_combination(8, &amp;[1, 3, 5, 7]), 6);
    assert_eq!(coin_change_combination(3, &amp;[1, 2]), 2);
    assert_eq!(coin_change_combination(2, &amp;[1, 2]), 2);
    assert_eq!(coin_change_combination(1, &amp;[1, 2]), 1);
    assert_eq!(coin_change_combination(5, &amp;[2, 3]), 1);
    assert_eq!(coin_change_combination(5, &amp;[1, 2, 3]), 5);
    assert_eq!(coin_change_combination(5, &amp;[1]), 1);
    assert_eq!(coin_change_combination(2, &amp;[3]), 0);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSISDtTZy8I9RqW7-TV-KxFZHPsd8yR4ChTloPvJT0vPE65AruoEFA6FY43PaHGL8uXYPnSr1cy26eP/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">use std::ops::RangeInclusive;

fn is_pandigital(a: u32, b: u32, ab: u32) -&gt; bool {
    let mut bits = 0u16;
    for n in [a, b, ab].iter_mut() {
        while *n &gt; 0 {
            let d = *n % 10;
            bits |= 1 &lt;&lt; d;
            *n /= 10;
        }
    }
    bits == 0b1111111110u16
}

fn sum_distinct(arr: &amp;mut [u32]) -&gt; u32 {
    arr.sort();
    let mut sum = 0u32;
    if let Some(&amp;n) = arr.get(0) {
        sum += n;
    }
    for i in 1..arr.len() {
        if arr[i - 1] != arr[i] {
            sum += arr[i];
        }
    }
    sum
}

fn explore_pandigital_combinations(
    a: RangeInclusive&lt;u32&gt;,
    b: RangeInclusive&lt;u32&gt;,
    products: &amp;mut Vec&lt;u32&gt;,
) {
    for a in a {
        for b in b.clone() {
            let ab = a * b;
            if ab &gt; 9876 {
                break;
            }
            if is_pandigital(a, b, ab) {
                products.push(ab);
            }
        }
    }
}

fn main() {
    let mut products = Vec::&lt;u32&gt;::new();
    explore_pandigital_combinations(2..=9, 1234..=9876, &amp;mut products);
    explore_pandigital_combinations(12..=98, 123..=987, &amp;mut products);
    let sum = sum_distinct(&amp;mut products);

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 45228);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTv92Dl9tdkwDmsM8mbO5O7zSCXlY4vALTd1xS7UukgX3Wd1d3kJHUQ4BSNdwTviue5IrSb3CpIq399/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">fn gcd(mut a: u32, mut b: u32) -&gt; u32 {
    if b &gt; a {
        std::mem::swap(&amp;mut a, &amp;mut b);
    }
    assert!(b != 0);
    let r = a % b;
    if r == 0 {
        return b;
    }
    gcd(b, r)
}

fn main() {
    let mut numerator = 1u32;
    let mut denominator = 1u32;
    for a in 1u32..=9 {
        for c in a..=9 {
            for d in a..c {
                if (10 * a + c) * d == (10 * c + d) * a &amp;&amp; a != d {
                    numerator *= a;
                    denominator *= d;
                }
            }
        }
    }
    let gcd = gcd(numerator, denominator);
    let ans = denominator / gcd;

    println!(&quot;{}&quot;, ans);
    assert_eq!(ans, 100);
}
</code></pre></pre>
<html><iframe frameborder="0" width="750" height="600" src="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20for%20c%20in%201u32..%3D9%20%7B%0A%20%20%20%20%20%20%20%20for%20d%20in%201u32..c%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20b%20in%20d..c%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20(10%20*%20d%20%2B%20b)%20*%20c%20%3D%3D%20(10%20*%20c%20%2B%20d)%20*%20b%20%26%26%20b%20!%3D%20c%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20panic!(%22this%20block%20must%20be%20unreachable!%22)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20for%20c%20in%201u32..%3D99%20%7B%0A%20%20%20%20%20%20%20%20for%20d%20in%201u32..c%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20b%20in%20d..c%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20df%20%3D%200.1f32%20*%20d%20as%20f32%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20bf%20%3D%200.1f32%20*%20b%20as%20f32%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20cf%20%3D%200.1f32%20*%20c%20as%20f32%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20(10f32%20*%20df%20%2B%20bf)%20*%20cf%20%3D%3D%20(10f32%20*%20cf%20%2B%20df)%20*%20bf%20%26%26%20b%20!%3D%20c%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22%7B%3A.1%7D%2F%7B%3A.1%7D%5Ct(%7B%3A.1%7D%20%7B%3A.1%7D%20%2F%20%7B%3A.1%7D%20%7B%3A.1%7D)%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20bf%2C%20cf%2C%20df%2C%20bf%2C%20cf%2C%20df%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A"></iframe></html>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTeoLqSi_tW6-cthF65pJrDdZJARY6fKE2jQAD_ZztTx_Q7SaxqQGvFqtQFD8bbdMqM8NFerkul_A57/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e30.html">Q.30 Digit fifth powers</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn build_factorial_tenfold() -&gt; [u32; 10] {
    let mut acc = 1u32;
    let mut factorial_tenfold = [1u32; 10];
    for n in 1..=9 {
        acc *= n;
        factorial_tenfold[n as usize] = acc;
    }
    factorial_tenfold
}

fn factorial_sum_10000_fold(factorial_tenfold: &amp;[u32; 10]) -&gt; [u32; 10000] {
    let mut factorial_sum_10000_fold = [0u32; 10000];
    factorial_sum_10000_fold[0] = 1;
    for i in 1..factorial_sum_10000_fold.len() {
        let mut sum = 0;
        let mut digits = i as u32;
        while digits &gt; 0 {
            let d = digits % 10;
            digits /= 10;
            sum += factorial_tenfold[d as usize];
        }
        factorial_sum_10000_fold[i] = sum;
    }
    factorial_sum_10000_fold
}

fn zero_pad_10000(carry: u32, residue: u32, sum: &amp;mut u32) {
    match (carry &gt; 0, residue) {
        (false, _) =&gt; (),
        (true, 0..=9) =&gt; *sum += 3,
        (true, 10..=99) =&gt; *sum += 2,
        (true, 100..=999) =&gt; *sum += 1,
        _ =&gt; (),
    }
}

fn match_factorial_sum_10000(target: u32, factorial_sum_10000_fold: &amp;[u32; 10000]) -&gt; bool {
    let mut digits = target;
    let mut sum = 0;
    while digits &gt; 0 {
        let d = digits % 10000;
        digits /= 10000;
        sum += factorial_sum_10000_fold[d as usize];
        zero_pad_10000(digits, d, &amp;mut sum);
        if sum &gt; target {
            return false;
        }
    }
    sum == target
}

fn digit_range_max(fact_nine: u32) -&gt; u32 {
    let mut digit_min = 1u32;
    let mut fact_sum_max = fact_nine;
    while digit_min &lt; fact_nine {
        digit_min *= 10;
        fact_sum_max += fact_nine;
    }
    fact_sum_max - fact_nine
}

fn main() {
    let factorial_tenfold = build_factorial_tenfold();
    let factorial_sum_10000_fold = factorial_sum_10000_fold(&amp;factorial_tenfold);
    let digit_range_max = digit_range_max(factorial_tenfold[9]);
    let sum = (3..digit_range_max)
        .filter(|&amp;d| match_factorial_sum_10000(d, &amp;factorial_sum_10000_fold)) 
        .sum::&lt;u32&gt;();

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 40730);
}
</code></pre></pre>
<html><iframe frameborder="0" width="750" height="600" src="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20factorial_digit_sum(99))%3B%0A%20%20%20%20assert_eq!(factorial_digit_sum(99)%2C%20362880%20*%202)%3B%0A%20%20%20%20assert_eq!(factorial_digit_sum(0)%2C%201)%3B%0A%20%20%20%20assert_eq!(factorial_digit_sum(123)%2C%201%20%2B%202%20%2B%202%20*%203)%3B%0A%7D%0A%0Afn%20factorial(n%3A%20u32)%20-%3E%20u32%20%7B%0A%20%20%20%20match%20n%20%7B%0A%20%20%20%20%20%20%20%200%20%7C%201%20%3D%3E%201%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20factorial(n%20-%201)%20*%20n%2C%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20factorial_digit_sum(mut%20n%3A%20u32)%20-%3E%20u32%20%7B%0A%20%20%20%20if%20n%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20return%201%3B%0A%20%20%20%20%7D%0A%20%20%20%20let%20mut%20sum%20%3D%200%3B%0A%20%20%20%20while%20n%20%3E%200%20%7B%0A%20%20%20%20%20%20%20%20let%20d%20%3D%20n%20%25%2010%3B%0A%20%20%20%20%20%20%20%20sum%20%2B%3D%20factorial(d)%3B%0A%20%20%20%20%20%20%20%20n%20%2F%3D%2010%3B%0A%20%20%20%20%7D%0A%20%20%20%20sum%0A%7D"></iframe></html>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQLeZrSYtP510YH7LfGMCBW4uvSbPXf5DK_l9J6Iqv0WJ28lz1NCES2x7NXZLRtAUHdiFRNNQf4rmxw/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e27.html">Q.27 Quadratic primes</a></li>
<li><a href="./e7.html">Q.7 10001st prime</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct Sieve {
    _sieve: Vec&lt;bool&gt;,
}

impl Sieve {
    fn rule_out(&amp;mut self, prime: usize) {
        for i in (prime * prime..self._sieve.len()).step_by(prime) {
            self._sieve[i] = false;
        }
    }
    fn init(&amp;mut self) {
        let sqrt = (self._sieve.len() as f64).sqrt() as usize;
        let mut index = 5usize;
        for &amp;i in [2usize, 4].iter().cycle() {
            if index &gt; sqrt {
                break;
            }
            if self._sieve[index] {
                self.rule_out(index);
            }
            index += i;
        }
    }
    fn new(below: u32) -&gt; Self {
        assert!(below &gt; 4);
        let sieve = vec![true; below as usize];
        let mut s = Self { _sieve: sieve };
        s.init();
        s
    }
    fn is_prime(&amp;self, n: u32) -&gt; bool {
        assert!(n &lt; self._sieve.len() as u32);
        if n == 2 || n == 3 {
            return true;
        }
        if n == 0 || n == 1 || n % 2 == 0 || n % 3 == 0 {
            return false;
        }
        self._sieve[n as usize]
    }
    fn primes(&amp;self, below: u32) -&gt; Vec&lt;u32&gt; {
        let mut primes: Vec&lt;u32&gt; = vec![2u32, 3u32];
        let mut index = 5usize;
        for &amp;i in [2usize, 4].iter().cycle() {
            if index &gt;= below as usize {
                break;
            }
            if self._sieve[index] {
                primes.push(index as u32);
            }
            index += i;
        }
        primes
    }
}

fn is_circular_prime(mut p: u32, sieve: &amp;Sieve) -&gt; bool {
    let log10 = (p as f32).log10();
    let exp10 = 10u32.pow(log10 as u32);
    for _ in 0..log10 as u8 {
        let d = p % 10;
        p /= 10;
        p += exp10 * d;
        if !sieve.is_prime(p) {
            return false;
        }
    }
    true
}

fn main() {
    let sieve = Sieve::new(1_000_000);
    let count = sieve
        .primes(1_000_000)
        .iter()
        .filter(|&amp;p| is_circular_prime(*p, &amp;sieve))
        .count();

    println!(&quot;{}&quot;, count);
    assert_eq!(count, 55);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQ0ZtzCE8VwDEPAGp74UYvs71GuC43mFdzIWDhqMGJg4TYY8jKck_IHVSH_TjqBtA-wb-cpyaufDjh6/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e4.html">Q.4 Largest palindrome product</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn generate_even_and_odd_palindromes(mut n: u32) -&gt; (u32, u32) {
    let mut ep = n.clone();
    let mut op = n.clone();
    op /= 10;
    while n &gt; 0 {
        ep *= 10;
        op *= 10;
        ep += n % 10;
        op += n % 10;
        n /= 10;
    }
    (ep, op)
}

fn is_double_based_palindrome(a: u32) -&gt; bool {
    if a % 2 == 0 {
        return false;
    }
    let mut t = a.clone();
    let mut b = 0u32;
    while t &gt; 0 {
        b &lt;&lt;= 1;
        b |= t &amp; 1;
        t &gt;&gt;= 1;
    }
    a == b
}

fn main() {
    let mut sum = 0u32;
    let half = 10u32.pow(1_000_000f32.log10() as u32 / 2);
    for n in 1..half {
        let (ep, op) = generate_even_and_odd_palindromes(n);
        if is_double_based_palindrome(ep) {
            sum += ep;
        }
        if is_double_based_palindrome(op) {
            sum += op;
        }
    }

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 872187);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">fn is_palindrome(a: u32) -&gt; bool {
    if a % 2 == 0 &amp;&amp; a % 11 != 0 {
        return false;
    }
    let mut t = a.clone();
    let mut b = 0u32;
    while t &gt; 0 {
        b *= 10;
        b += t % 10;
        t /= 10;
    }
    a == b
}

fn is_double_based_palindrome(a: u32) -&gt; bool {
    if a % 2 == 0 {
        return false;
    }
    let mut t = a.clone();
    let mut b = 0u32;
    while t &gt; 0 {
        b &lt;&lt;= 1;
        b |= t &amp; 1;
        t &gt;&gt;= 1;
    }
    a == b
}

fn main() {
    let sum = (1..1_000_000)
        .step_by(2)
        .filter(|&amp;n| is_palindrome(n))
        .filter(|&amp;n| is_double_based_palindrome(n))
        .sum::&lt;u32&gt;();

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 872187);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vRQ1EPSJX1kXQGs_PRvaEtOIxtFA4Q9rccZ9K5mXQ5LFJXjMeTwCTjctMo1mKPERQOsJGvNFYrw4t2a/embed?start=false&loop=false&delayms=3000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="https://oeis.org/A020994">A020994 Primes that are both left-truncatable and right-truncatable.</a></li>
<li><a href="./e36.html">Q.36 Double-base palindromes</a></li>
</ul>
<html><center><img src="./imgs/truncatable-primes.gif"></center></html>
<pre><pre class="playground"><code class="language-rust editable">fn is_prime(n: u32) -&gt; bool {
    if n &lt; 2 {
        return false;
    }
    if n == 2 || n == 3 || n == 5 {
        return true;
    }
    for d in &amp;[2u32, 3, 5] {
        if n % *d == 0 {
            return false;
        }
    }
    let side = (n as f32).sqrt() as u32;
    let mut d = 5u32;
    for i in [2u32, 4].iter().cycle() {
        if d &gt; side {
            break;
        }
        d += *i;
        if n % d == 0 {
            return false;
        }
    }
    true
}

fn generate_right_truncatable_maybe_prime_numbers(mut p: u32) -&gt; (u32, u32, u32, u32) {
    p *= 10;
    (p + 1, p + 3, p + 7, p + 9)
}

fn is_left_trancatable_prime(p: u32) -&gt; bool {
    let mut d = 10u32;
    while d &lt; p {
        if !is_prime(p % d) {
            return false;
        }
        d *= 10;
    }
    true
}

fn expand_right_truncatable_prime(p: u32, left_truncatable_prime_sum: &amp;mut u32) {
    if is_left_trancatable_prime(p) {
        *left_truncatable_prime_sum += p;
    }
    let (n1, n2, n3, n4) = generate_right_truncatable_maybe_prime_numbers(p);
    for &amp;p in [n1, n2, n3, n4].iter().filter(|&amp;n| is_prime(*n)) {
        expand_right_truncatable_prime(p, left_truncatable_prime_sum);
    }
}

fn main() {
    let mut left_truncatable_prime_sum = 0u32;
    for &amp;p in [2u32, 3, 5, 7].iter() {
        expand_right_truncatable_prime(p, &amp;mut left_truncatable_prime_sum);
    }

    println!(&quot;{}&quot;, left_truncatable_prime_sum - 2 - 3 - 5 - 7);
    assert_eq!(left_truncatable_prime_sum - 2 - 3 - 5 - 7, 748317);
}
</code></pre></pre>
<hr />
<ul>
<li><a href="./e7.html">Q.7 10001st prime</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct Index {
    i: usize,
    _ite: Box&lt;dyn Iterator&lt;Item = usize&gt;&gt;,
}

impl Index {
    fn increment(&amp;mut self) {
        self.i += self._ite.next().unwrap();
    }
    fn new() -&gt; Self {
        Self {
            i: 5,
            _ite: Box::new(vec![2usize, 4].into_iter().cycle()),
        }
    }
}

struct Sieve {
    _sieve: Vec&lt;bool&gt;,
    _primes: Vec&lt;usize&gt;,
    _index: Index,
    _queue: std::collections::VecDeque&lt;usize&gt;,
}

impl Sieve {
    fn rule_out(&amp;mut self, prime: usize) {
        for i in (prime * prime..self._sieve.len()).step_by(prime) {
            self._sieve[i] = false;
        }
    }
    fn clean_sieve(&amp;mut self) {
        let sqrt = (self._sieve.len() as f32).sqrt() as usize;
        while self._index.i &lt;= sqrt {
            if self._sieve[self._index.i] {
                self._primes.push(self._index.i);
                self._queue.push_back(self._index.i);
                self.rule_out(self._index.i);
            }
            self._index.increment();
        }
        while self._index.i &lt; self._sieve.len() {
            if self._sieve[self._index.i] {
                self._primes.push(self._index.i);
                self._queue.push_back(self._index.i);
            }
            self._index.increment();
        }
    }
    fn new(below: u32) -&gt; Self {
        assert!(below &gt; 4);
        let sieve = vec![true; below as usize];
        let mut s = Self {
            _sieve: sieve,
            _primes: vec![],
            _index: Index::new(),
            _queue: std::collections::VecDeque::new(),
        };
        s._queue.push_back(2);
        s._queue.push_back(3);
        s.clean_sieve();
        s
    }
    fn extend(&amp;mut self) {
        self._sieve.extend(vec![true; self._sieve.len()]);
        let primes = self._primes.clone();
        for &amp;p in primes.iter() {
            self.rule_out(p);
        }
        self.clean_sieve();
    }
    fn is_prime(&amp;mut self, n: u32) -&gt; bool {
        if n == 2 || n == 3 {
            return true;
        }
        if n == 0 || n == 1 || n % 2 == 0 || n % 3 == 0 {
            return false;
        }
        while n &gt; self._sieve.len() as u32 - 1 {
            self.extend();
        }
        self._sieve[n as usize]
    }
    fn next_prime(&amp;mut self) -&gt; u32 {
        loop {
            if let Some(p) = self._queue.pop_front() {
                return p as u32;
            }
            self.extend();
        }
    }
    fn is_left_trancatable_prime(&amp;mut self, p: u32) -&gt; bool {
        let mut d = 10u32;
        while d &lt; p {
            if !self.is_prime(p % d) {
                return false;
            }
            d *= 10;
        }
        true
    }
    fn is_right_trancatable_prime(&amp;mut self, p: u32) -&gt; bool {
        let mut d = 10u32;
        while d &lt; p {
            if !self.is_prime(p / d) {
                return false;
            }
            d *= 10;
        }
        true
    }
}

fn main() {
    let mut sum = 0u32;
    let mut sieve = Sieve::new(10_000);
    let mut count = 0u8;
    while count &lt; 15 {
        let p = sieve.next_prime();
        if !sieve.is_left_trancatable_prime(p) {
            continue;
        }
        if !sieve.is_right_trancatable_prime(p) {
            continue;
        }
        count += 1;
        sum += p;
    }

    println!(&quot;{}&quot;, sum - 2 - 3 - 5 - 7);
    assert_eq!(sum - 2 - 3 - 5 - 7, 748317);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTsLG85pV1UgRu7c9aeIxtiMFDiBVU6OiofSCYJGnL_q7vuRy9oA1b5lKcO21bBiHoeIde5m7q0hYIy/embed?start=false&loop=false&delayms=3000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e32.html">Q.32 Pandigital products</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn is_pandigital(a: u32, b: u32) -&gt; bool {
    let mut bits = 0u16;
    for n in [a, b].iter_mut() {
        while *n &gt; 0 {
            let d = *n % 10;
            *n /= 10;
            bits |= 1 &lt;&lt; d;
        }
    }
    bits == 0b1111111110u16
}

fn largest_pandigital_concatenated_product() -&gt; u32 {
    for n in (9183..=(19000 / 2) as u32).rev() {
        if is_pandigital(n, n * 2) {
            return n * 100_000 + 2 * n;
        }
    }
    918_273_645
}

fn main() {
    let max = largest_pandigital_concatenated_product();

    println!(&quot;{}&quot;, max);
    assert_eq!(max, 932718654);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSnRa1g-1SUbqgs74KSCrAsB9mbj2BjTEPx1xiIw-NV3cQ3E_imRbW1-g6zmggkv25T1dgqgzYbsvjc/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/QJYmyhnaaek" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<ul>
<li><a href="./e9.html">Q.9 Special Pythagorean triplet</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn gcd(mut a: usize, mut b: usize) -&gt; usize {
    if b &gt; a {
        std::mem::swap(&amp;mut a, &amp;mut b);
    }
    assert!(b != 0);
    let r = a % b;
    if r == 0 {
        return b;
    }
    gcd(b, r)
}

fn main() {
    let mut counts = [0u8; 1001];
    for p in (12..=1000).step_by(2) {
        for m in 2..=(((p - 2) / 2) as f32).sqrt() as usize {
            for n in ((if m % 2 == 0 { 1 } else { 2 })..m).step_by(2) {
                let a = m * m - n * n;
                let b = 2 * m * n;
                let c = m * m + n * n;
                if a + b + c == p &amp;&amp; gcd(m, n) == 1 {
                    for k in (p..=1000).step_by(p) {
                        counts[k] += 1;
                    }
                }
            }
        }
    }
    let (p, _) = counts
        .iter()
        .enumerate()
        .reduce(|(ap, a), (bp, b)| if *a &gt; *b { (ap, a) } else { (bp, b) })
        .unwrap();

    println!(&quot;{}&quot;, p);
    assert_eq!(p, 840);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut counts = [0u8; 1001];
    for c in 3..=997 {
        let mut b = 2;
        while b &lt; 1000 - c &amp;&amp; b &lt; c {
            let mut a = 1;
            while a &lt;= 1000 - c - b &amp;&amp; a &lt; b {
                if c * c == b * b + a * a {
                    counts[c + b + a] += 1;
                }
                a += 1;
            }
            b += 1;
        }
    }
    let (p, _) = counts
        .iter()
        .enumerate()
        .reduce(|(ap, a), (bp, b)| if *a &gt; *b { (ap, a) } else { (bp, b) })
        .unwrap();

    println!(&quot;{}&quot;, p);
    assert_eq!(p, 840);
}
</code></pre></pre>
<html><iframe frameborder="0" width="750" height="600" src="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20assert_eq!(count_brute()%2C%20count_euclid())%3B%0A%7D%0A%0Afn%20count_brute()%20-%3E%20%5Bu8%3B%201001%5D%20%7B%0A%20%20%20%20println!(%22%5CnBrute%20force%22)%3B%0A%20%20%20%20let%20mut%20counts%20%3D%20%5B0u8%3B%201001%5D%3B%0A%20%20%20%20for%20c%20in%203..%3D997%20%7B%0A%20%20%20%20%20%20%20%20let%20mut%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20while%20b%20%3C%201000%20-%20c%20%26%26%20b%20%3C%20c%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20while%20a%20%3C%3D%201000%20-%20c%20-%20b%20%26%26%20a%20%3C%20b%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20c%20*%20c%20%3D%3D%20b%20*%20b%20%2B%20a%20*%20a%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22p%3A%7B%7D%5Cta%3A%7B%7D%5Ctb%3A%7B%7D%5Ctc%3A%7B%7D%22%2C%20a%20%2B%20b%20%2B%20c%2C%20a%2C%20b%2C%20c)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20counts%5Bc%20%2B%20b%20%2B%20a%5D%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20a%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20b%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20counts%0A%7D%0A%0Afn%20count_euclid()%20-%3E%20%5Bu8%3B%201001%5D%20%7B%0A%20%20%20%20println!(%22%5CnEuclid%22)%3B%0A%20%20%20%20let%20mut%20counts%20%3D%20%5B0u8%3B%201001%5D%3B%0A%20%20%20%20for%20p%20in%20(12..%3D1000).step_by(2)%20%7B%0A%20%20%20%20%20%20%20%20for%20m%20in%202..%3D(((p%20-%202)%20%2F%202)%20as%20f32).sqrt()%20as%20usize%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20n%20in%20((if%20m%20%25%202%20%3D%3D%200%20%7B%201%20%7D%20else%20%7B%202%20%7D)..m).step_by(2)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20a%20%3D%20m%20*%20m%20-%20n%20*%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20b%20%3D%202%20*%20m%20*%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20c%20%3D%20m%20*%20m%20%2B%20n%20*%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20a%20%2B%20b%20%2B%20c%20%3D%3D%20p%20%26%26%20gcd(m%2C%20n)%20%3D%3D%201%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20for%20k%20in%20(p..%3D1000).step_by(p)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22kp%3A%7B%7D%5Cta%3A%7B%7D%5Ctb%3A%7B%7D%5Ctc%3A%7B%7D%22%2C%20k%2C%20a%2C%20b%2C%20c)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20counts%5Bk%5D%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20counts%0A%7D%0A%0Afn%20gcd(mut%20a%3A%20usize%2C%20mut%20b%3A%20usize)%20-%3E%20usize%20%7B%0A%20%20%20%20if%20b%20%3E%20a%20%7B%0A%20%20%20%20%20%20%20%20std%3A%3Amem%3A%3Aswap(%26mut%20a%2C%20%26mut%20b)%3B%0A%20%20%20%20%7D%0A%20%20%20%20assert!(b%20!%3D%200)%3B%0A%20%20%20%20let%20r%20%3D%20a%20%25%20b%3B%0A%20%20%20%20if%20r%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20return%20b%3B%0A%20%20%20%20%7D%0A%20%20%20%20gcd(b%2C%20r)%0A%7D%0A"></iframe></html>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQIUKRup3lhAHlPAyjntYoH31NebqP83YZx2ypaHvrwMwszPfip41PqpJagbB9kOGzdTdOxI7ryyY90/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">struct Container {
    capacity: u32,
    elements: u32,
}

fn digit_at(nth: u32) -&gt; u8 {
    let mut container = Container {
        capacity: 0,
        elements: 0,
    };
    let mut w = 1u32;
    loop {
        let elements = 10u32.pow(w) - 10u32.pow(w - 1);
        let capacity = w * elements;
        if nth &lt; container.capacity + capacity {
            break;
        }
        container.capacity += capacity;
        container.elements += elements;
        w += 1;
    }
    let residue = nth - container.capacity;
    if residue % w == 0 {
        return ((container.elements + residue / w) % 10) as u8;
    }
    let num = container.elements + residue / w + 1;
    ((num / 10u32.pow(w - residue % w)) % 10) as u8
}

fn main() {
    let p = (0u32..=6)
        .map(|d| 10u32.pow(d))
        .map(|d| digit_at(d))
        .map(|d| d as u32)
        .product::&lt;u32&gt;();

    println!(&quot;{}&quot;, p);
    assert_eq!(p, 210);

    assert_eq!(digit_at(1), 1);
    assert_eq!(digit_at(9), 9);
    assert_eq!(digit_at(17), 3);
    assert_eq!(digit_at(18), 1);
    assert_eq!(digit_at(189), 9);
    assert_eq!(digit_at(190), 1);
    assert_eq!(digit_at(194), 0);
    assert_eq!(digit_at(37371), 6);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vS-EtnNcNcQBTQdtQW9zwrHht5UudgLZJu3r8A7a_JYngby1XpZuUx1oECisxLVw44-WRT0It7u9NkY/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">fn consume(usable_items: &amp;Vec&lt;u32&gt;, accumulated_num: u32, drain: &amp;mut Vec&lt;u32&gt;) {
    if usable_items.len() == 0 {
        drain.push(accumulated_num);
        return;
    }
    for i in 0..usable_items.len() {
        let mut items = usable_items.clone();
        let mut num = accumulated_num.clone();
        let n = items.remove(i);
        num *= 10;
        num += n;
        consume(&amp;items, num, drain);
    }
}

fn permutations(n: u32) -&gt; Vec&lt;u32&gt; {
    let items = (1..=n).into_iter().rev().collect::&lt;Vec&lt;u32&gt;&gt;();
    let capacity = items.iter().map(|&amp;i| i).product::&lt;u32&gt;() as usize;
    let mut drain = Vec::with_capacity(capacity);
    consume(&amp;items, 0, &amp;mut drain);
    drain
}

fn is_prime(n: u32) -&gt; bool {
    if n &lt; 2 {
        return false;
    }
    if n == 2 || n == 3 || n == 5 {
        return true;
    }
    for d in &amp;[2u32, 3, 5] {
        if n % *d == 0 {
            return false;
        }
    }
    let side = (n as f32).sqrt() as u32;
    let mut d = 5u32;
    for i in [2u32, 4].iter().cycle() {
        if d &gt; side {
            break;
        }
        d += *i;
        if n % d == 0 {
            return false;
        }
    }
    true
}

fn main() {
    let mut p = None;
    'exploration: for &amp;d in [7, 4].iter() {
        for n in permutations(d) {
            if is_prime(n) {
                p = Some(n);
                break 'exploration;
            }
        }
    }

    println!(&quot;{:?}&quot;, p);
    assert_eq!(p, Some(7652413));
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQ2FQxQcLA2fMTFCiUCLPH12QHPuOO1XRo--NMwlMM617EX2VSjOQ4ws3CE2pUtiTdZNfvA1H-Q3K5o/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e12.html">Q.12 Highly divisible triangular number</a></li>
<li><a href="./e8.html">Q.8 Largest product in a series</a></li>
</ul>
<p>Because the original word list is very long, this example has only a part of it.</p>
<pre><pre class="playground"><code class="language-rust editable">fn is_triangle_number(x: u32) -&gt; bool {
    let expr = 8 * x + 1;
    let side = (expr as f64).sqrt() as u32;
    side * side == expr
}

fn word_value(w: &amp;str) -&gt; u32 {
    w.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::&lt;u32&gt;()
}

fn main() {
    let count = WORDS
        .iter()
        .map(|&amp;w| word_value(w))
        .filter(|&amp;v| is_triangle_number(v))
        .count();

    println!(&quot;{:?}&quot;, count);
    assert_eq!(count, 5);
}

const WORDS: &amp;[&amp;str] = &amp;[
    &quot;A&quot;,
    &quot;ABILITY&quot;,
    &quot;ABLE&quot;,
    &quot;ABOUT&quot;,
    &quot;ABOVE&quot;,
    &quot;ABSENCE&quot;,
    &quot;ABSOLUTELY&quot;,
    &quot;ACADEMIC&quot;,
    &quot;ACCEPT&quot;,
    &quot;ACCESS&quot;,
    &quot;ACCIDENT&quot;,
    &quot;ACCOMPANY&quot;,
    &quot;ACCORDING&quot;,
    &quot;ACCOUNT&quot;,
    &quot;ACHIEVE&quot;,
    &quot;ACHIEVEMENT&quot;,
    &quot;ACID&quot;
];
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSYdejgkeaE4x3PSVZJ-bFyVAOrRNPau82VTV0-rplstTig2AcYW2cHVX0u8ogr-OZZbr3Mwr9IpgTk/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e41.html">Q.41 Pandigital prime</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn is_divisible(n: u64, depth: u8) -&gt; bool {
    if depth &lt; 2 || depth == 9 {
        return true;
    }
    let p = match depth {
        2 =&gt; 17,
        3 =&gt; 13,
        4 =&gt; 11,
        5 =&gt; 7,
        6 =&gt; 5,
        7 =&gt; 3,
        8 =&gt; 2,
        _ =&gt; panic!(),
    };
    (n / 10u64.pow(depth as u32 - 2)) % p == 0
}

fn consume(
    usable_items: &amp;Vec&lt;u8&gt;,
    accumulated_num: u64,
    drain: &amp;mut Vec&lt;u64&gt;,
    depth: u8,
) {
    if usable_items.len() == 0 {
        drain.push(accumulated_num);
        return;
    }
    for i in 0..usable_items.len() {
        let mut items = usable_items.clone();
        let mut num = accumulated_num.clone();
        let n = items.remove(i);
        let weight = 10u64.pow(depth as u32);
        num += weight * n as u64;
        if !is_divisible(num, depth) {
            continue;
        }
        consume(&amp;items, num, drain, depth + 1);
    }
}

fn permutations_with_conditions() -&gt; Vec&lt;u64&gt; {
    let items = (0..=9).into_iter().collect::&lt;Vec&lt;u8&gt;&gt;();
    let mut drain = vec![];
    consume(&amp;items, 0, &amp;mut drain, 0);
    drain
}

fn main() {
    let sum = permutations_with_conditions()
        .iter()
        .filter(|&amp;n| *n &gt; 999_999_999)
        .sum::&lt;u64&gt;();

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 16695334890);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">fn is_divisible(n: u64, depth: u8) -&gt; bool {
    if depth &lt; 3 {
        return true;
    }
    let p = match depth {
        3 =&gt; 2,
        4 =&gt; 3,
        5 =&gt; 5,
        6 =&gt; 7,
        7 =&gt; 11,
        8 =&gt; 13,
        9 =&gt; 17,
        _ =&gt; panic!(),
    };
    (n % 1000) % p == 0
}

fn consume(
    usable_items: &amp;Vec&lt;u8&gt;,
    accumulated_num: u64,
    drain: &amp;mut Vec&lt;u64&gt;,
    depth: u8,
) {
    if usable_items.len() == 0 {
        drain.push(accumulated_num);
        return;
    }
    for i in 0..usable_items.len() {
        let mut items = usable_items.clone();
        let mut num = accumulated_num.clone();
        let n = items.remove(i);
        num *= 10;
        num += n as u64;
        if !is_divisible(num, depth) {
            continue;
        }
        consume(&amp;items, num, drain, depth + 1);
    }
}

fn permutations_with_conditions() -&gt; Vec&lt;u64&gt; {
    let items = (0..=9).into_iter().collect::&lt;Vec&lt;u8&gt;&gt;();
    let mut drain = vec![];
    consume(&amp;items, 0, &amp;mut drain, 0);
    drain
}

fn main() {
    let sum = permutations_with_conditions()
        .iter()
        .filter(|&amp;n| *n &gt; 999_999_999)
        .sum::&lt;u64&gt;();

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 16695334890);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSMZszzJpj30CKt2_noc6bBnew7m4JwxujysybKLAZZCXPHOrC2TrXZ43M8Sfe22cKYmemgq9KLE1UV/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e42.html">Q.42 Coded triangle numbers</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn is_pentagonal(n: u64) -&gt; bool {
    let expr = 24 * n + 1;
    let sqrt = (expr as f64).sqrt() as u64;
    if expr != sqrt * sqrt {
        return false;
    }
    sqrt % 6 == 5
}

fn pentagon(n: u64) -&gt; u64 {
    n * (3 * n - 1) / 2
}

fn calc_distance(pentagons: &amp;mut Vec&lt;u64&gt;) -&gt; (u64, u64) {
    for n in 1u64.. {
        let p1 = pentagon(n);
        for &amp;p2 in pentagons.iter().rev() {
            let d = p1 - p2;
            let s = p1 + p2;
            if is_pentagonal(d) &amp;&amp; is_pentagonal(s) {
                return (d, n);
            }
        }
        pentagons.push(p1);
    }
    panic!(&quot;This function is supposed to have return but not break in the outermost loop!&quot;);
}

fn is_answer_confirmed(pentagons: &amp;mut Vec&lt;u64&gt;, distance: u64, nth: u64) -&gt; bool {
    pentagons.push(pentagon(nth));
    for n in nth + 1.. {
        let p1 = pentagon(n);
        if 3 * (n - 1) + 1 &gt; distance {
            return true;
        }
        for &amp;p2 in pentagons.iter().rev() {
            let d = p1 - p2;
            if d &gt;= distance {
                break;
            }
            let s = p1 + p2;
            if is_pentagonal(d) &amp;&amp; is_pentagonal(s) {
                return false;
            }
        }
        pentagons.push(p1);
    }
    panic!(&quot;This function is supposed to have return but not break in the outermost loop!&quot;);
}

fn main() {
    let mut pentagons = vec![];
    let (d, nth) = calc_distance(&amp;mut pentagons);
    assert!(is_answer_confirmed(&amp;mut pentagons, d, nth));

    println!(&quot;{}&quot;, d);
    assert_eq!(d, 5482660);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSnWKImUZLJQbkm855cLC6Jew2ogWHv8JjSSvpmijO1HPXfKtJDmXaPrpZAIZje8cnPTzXy4SRgpyY4/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<pre><pre class="playground"><code class="language-rust editable">struct Pentagon {
    n: u64,
    v: u64,
}

impl Pentagon {
    fn increment(&amp;mut self) {
        self.v += self.n * 3 + 1;
        self.n += 1;
    }
    fn value(&amp;self) -&gt; u64 {
        self.v
    }
}

struct Hexagon {
    n: u64,
    v: u64,
}

impl Hexagon {
    fn increment(&amp;mut self) {
        self.v += 4 * self.n + 1;
        self.n += 1;
    }
    fn value(&amp;self) -&gt; u64 {
        self.v
    }
}

fn main() {
    let mut p = Pentagon { n: 165, v: 40755 };
    let mut h = Hexagon { n: 143, v: 40755 };
    p.increment();
    let v = loop {
        while p.value() &lt; h.value() {
            p.increment();
        }
        while h.value() &lt; p.value() {
            h.increment();
        }
        if p.value() == h.value() {
            break p.value();
        }
    };

    println!(&quot;{}&quot;, v);
    assert_eq!(v, 1533776805);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTlQQGORa93Q02zGf1CJWM3aHW0ambeBVhxaMbVwQjlHZB6wveuIWJa5SpoNQWOht3Z4sGlOQwXE0N0/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e37.html">Q.37 Truncatable primes</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct Index {
    i: usize,
    _ite: Box&lt;dyn Iterator&lt;Item = usize&gt;&gt;,
}

impl Index {
    fn increment(&amp;mut self) {
        self.i += self._ite.next().unwrap();
    }
    fn new() -&gt; Self {
        Self {
            i: 5,
            _ite: Box::new(vec![2usize, 4].into_iter().cycle()),
        }
    }
}

struct Sieve {
    _sieve: Vec&lt;bool&gt;,
    _primes: Vec&lt;usize&gt;,
    _index: Index,
}

impl Sieve {
    fn rule_out(&amp;mut self, prime: usize) {
        for i in (prime * prime..self._sieve.len()).step_by(prime) {
            self._sieve[i] = false;
        }
    }
    fn clean_sieve(&amp;mut self) {
        let sqrt = (self._sieve.len() as f32).sqrt() as usize;
        while self._index.i &lt;= sqrt {
            if self._sieve[self._index.i] {
                self._primes.push(self._index.i);
                self.rule_out(self._index.i);
            }
            self._index.increment();
        }
        while self._index.i &lt; self._sieve.len() {
            if self._sieve[self._index.i] {
                self._primes.push(self._index.i);
            }
            self._index.increment();
        }
    }
    fn new(below: u32) -&gt; Self {
        assert!(below &gt; 4);
        let sieve = vec![true; below as usize];
        let mut s = Self {
            _sieve: sieve,
            _primes: vec![],
            _index: Index::new(),
        };
        s.clean_sieve();
        s
    }
    fn extend(&amp;mut self) {
        self._sieve.extend(vec![true; self._sieve.len()]);
        let primes = self._primes.clone();
        for &amp;p in primes.iter() {
            self.rule_out(p);
        }
        self.clean_sieve();
    }
    fn is_prime(&amp;mut self, n: u32) -&gt; bool {
        if n == 2 || n == 3 {
            return true;
        }
        if n == 0 || n == 1 || n % 2 == 0 || n % 3 == 0 {
            return false;
        }
        while n &gt; self._sieve.len() as u32 - 1 {
            self.extend();
        }
        self._sieve[n as usize]
    }
}

struct DoubleSquares {
    _n: u32,
    _elements: Vec&lt;u32&gt;,
}

impl DoubleSquares {
    fn new() -&gt; Self {
        Self {
            _n: 5,
            _elements: vec![2, 8, 18, 32, 50],
        }
    }
    fn extend(&amp;mut self) {
        for n in self._n + 1..self._n * 2 {
            self._elements.push(n * n * 2);
        }
        self._n *= 2;
    }
    fn double_check(&amp;mut self, sieve: &amp;mut Sieve, o: u32) -&gt; Result&lt;(), ()&gt; {
        while o &gt; self._elements.last().map(|&amp;n| n).unwrap_or(0) {
            self.extend();
        }
        for &amp;d in &amp;self._elements {
            if d &gt;= o {
                return Err(());
            }
            if sieve.is_prime(o - d) {
                return Ok(());
            }
        }
        panic!(&quot;This function is supposed to have return but not break in loop!&quot;);
    }
}

fn explore_error_value() -&gt; u32 {
    let mut sieve = Sieve::new(1000);
    let mut double_squares = DoubleSquares::new();
    for o in (9..).step_by(2) {
        if sieve.is_prime(o) {
            continue;
        }
        if double_squares.double_check(&amp;mut sieve, o).is_err() {
            return o;
        }
    }
    panic!(&quot;This function is supposed to have return but not break in loop!&quot;);
}

fn main() {
    let e = explore_error_value();
    println!(&quot;{}&quot;, e);
    assert_eq!(e, 5777);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vT5VS6MSSYOLCH2Urwrnaa2LjYSJx8tCUMBPQQZL-b9KLK0WtnYq6vpfYOmAkltBkPfrYSaL5Q5xLBG/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e37.html">Q.37 Truncatable primes</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct Sieve {
    _sieve: Vec&lt;bool&gt;,
    _count: Vec&lt;u8&gt;,
    _primes: Vec&lt;usize&gt;,
    _cursor: usize,
}

impl Sieve {
    fn rule_out(&amp;mut self, prime: usize) {
        for i in (prime..self._sieve.len()).step_by(prime) {
            self._sieve[i] = false;
            self._count[i] += 1;
        }
    }
    fn rule_out_from_previous_position(&amp;mut self, prime: usize, pp: usize) {
        for i in (prime..self._sieve.len()).step_by(prime) {
            if pp &gt; i {
                continue;
            }
            self._sieve[i] = false;
            self._count[i] += 1;
        }
    }
    fn is_start_of_four_consective_nums_with_factors(&amp;self) -&gt; bool {
        let i = self._cursor;
        if self._count[i] != 4 {
            return false;
        }
        if self._count.len() - 1 &lt; i + 3 {
            return false;
        }
        self._count[i + 1] == 4 &amp;&amp; self._count[i + 2] == 4 &amp;&amp; self._count[i + 3] == 4
    }
    fn clean_sieve_with_exploration(&amp;mut self) -&gt; Option&lt;u32&gt; {
        while self._cursor &lt; self._sieve.len() {
            if self._sieve[self._cursor] {
                self._primes.push(self._cursor);
                self.rule_out(self._cursor);
                continue;
            }
            if self.is_start_of_four_consective_nums_with_factors() {
                return Some(self._cursor as u32);
            }
            self._cursor += 1;
        }
        None
    }
    fn new(below: u32) -&gt; Self {
        assert!(below &gt; 4);
        let sieve = vec![true; below as usize];
        let count = vec![0u8; below as usize];
        Self {
            _sieve: sieve,
            _count: count,
            _primes: vec![],
            _cursor: 2,
        }
    }
    fn extend(&amp;mut self) {
        let prev_len = self._sieve.len();
        self._sieve.extend(vec![true; self._sieve.len()]);
        self._count.extend(vec![0u8; self._count.len()]);
        let primes = self._primes.clone();
        for &amp;p in primes.iter() {
            self.rule_out_from_previous_position(p, prev_len);
        }
    }
}

fn main() {
    let mut sieve = Sieve::new(10_000);
    let n = loop {
        if let Some(n) = sieve.clean_sieve_with_exploration() {
            break n;
        }
        sieve.extend();
    };

    println!(&quot;{}&quot;, n);
    assert_eq!(n, 134043);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQbWsPc8c8lR0_N7F3BD1GWuxXxXZJnlrL0N4-WTxGG_L5vPCw99cQHOnwyclEvs6e7T7XvPDIei0ES/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e2.html">Q.2 Even Fibonacci numbers</a></li>
<li><a href="./e26.html">Q.26 Reciprocal cycles</a></li>
<li><a href="https://cp-algorithms.com/algebra/binary-exp.html#toc-tgt-3">Binary Exponentiation - CP-Algorithms</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn conservative_mod_pow(a: u64, exp: u64, m: u64) -&gt; u64 {
    let mut result = 1;
    for _ in 0..exp {
        result *= a;
        result %= m;
    }
    result
}

fn main() {
    let m = 10_000_000_000;
    let mut sum = 0u64;
    for n in 1..=1000 {
        sum += conservative_mod_pow(n, n, m);
        sum %= m;
    }

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 9110846700);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">fn mod_pow(a: u64, exp: u64, m: u64) -&gt; u64 {
    let (mut a, mut exp, m) = (a as u128, exp as u128, m as u128);
    if m == 1 {
        return 0;
    }
    if exp == 0 {
        return 1;
    }
    let mut result = 1;
    a %= m;
    loop {
        if exp % 2 == 1 {
            result *= a;
            result %= m;
        }
        exp &gt;&gt;= 1;
        if exp == 0 {
            break;
        }
        a *= a;
        a %= m;
    }
    result as u64
}

fn main() {
    let m = 10_000_000_000u64;
    let mut sum = 0u64;
    for n in 1..=1000 {
        sum += mod_pow(n, n, m);
        sum %= m;
    }

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 9110846700);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQDxj9nj8K0454gcHtHOG5vQMsB8-6fbuntbPXnx1Q7kcK2_MPEuQ07-6RGy4duihoi5WpyaukQ40mQ/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e38.html">Q.38 Pandigital multiples</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">struct Sieve {
    _sieve: Vec&lt;bool&gt;,
}

impl Sieve {
    fn rule_out(&amp;mut self, prime: usize) {
        for i in (prime * prime..self._sieve.len()).step_by(prime) {
            self._sieve[i] = false;
        }
    }
    fn init(&amp;mut self) {
        let sqrt = (self._sieve.len() as f64).sqrt() as usize;
        let mut index = 5usize;
        for &amp;i in [2usize, 4].iter().cycle() {
            if index &gt; sqrt {
                break;
            }
            if self._sieve[index] {
                self.rule_out(index);
            }
            index += i;
        }
    }
    fn new(below: u32) -&gt; Self {
        assert!(below &gt; 4);
        let sieve = vec![true; below as usize];
        let mut s = Self { _sieve: sieve };
        s.init();
        s
    }
    fn is_prime(&amp;self, n: u32) -&gt; bool {
        assert!(n &lt; self._sieve.len() as u32);
        if n == 2 || n == 3 {
            return true;
        }
        if n == 0 || n == 1 || n % 2 == 0 || n % 3 == 0 {
            return false;
        }
        self._sieve[n as usize]
    }
    fn primes(&amp;self, below: u32) -&gt; Vec&lt;u32&gt; {
        let mut primes: Vec&lt;u32&gt; = vec![2u32, 3u32];
        let mut index = 5usize;
        for &amp;i in [2usize, 4].iter().cycle() {
            if index &gt;= below as usize {
                break;
            }
            if self._sieve[index] {
                primes.push(index as u32);
            }
            index += i;
        }
        primes
    }
}

fn is_permutations(mut a: u32, mut b: u32, mut c: u32) -&gt; bool {
    assert!(a &gt; 999 &amp;&amp; b &gt; 999 &amp;&amp; c &gt; 999);
    assert!(a &lt; 10000 &amp;&amp; b &lt; 10000 &amp;&amp; c &lt; 10000);
    for n in [&amp;mut a, &amp;mut b, &amp;mut c].iter_mut() {
        **n *= 10;
        **n += 1;
    }
    let (mut a_bits, mut b_bits, mut c_bits) = (0u16, 0u16, 0u16);
    for (n, bits) in [
        (&amp;mut a, &amp;mut a_bits),
        (&amp;mut b, &amp;mut b_bits),
        (&amp;mut c, &amp;mut c_bits),
    ]
    .iter_mut()
    {
        while **n &gt; 1 {
            let d = **n % 10;
            **n /= 10;
            **bits |= 1 &lt;&lt; d;
        }
    }
    a_bits == b_bits &amp;&amp; b_bits == c_bits
}

fn main() {
    let sieve = Sieve::new(10_000);
    let series = sieve
        .primes(10_000)
        .iter()
        .filter(|&amp;p| *p &gt; 999 &amp;&amp; *p &lt; 10_000 - 6660)
        .filter(|&amp;p| sieve.is_prime(*p + 3330) &amp;&amp; sieve.is_prime(*p + 6660))
        .filter(|&amp;p| *p != 1487)
        .filter(|&amp;p| is_permutations(*p, *p + 3330, *p + 6660))
        .map(|&amp;p| p as u64)
        .map(|p| p * 100_000_000 + (p + 3330) * 10_000 + p + 6660)
        .last()
        .expect(&quot;The prime series with a difference of 3330 not found!&quot;);

    println!(&quot;{}&quot;, series);
    assert_eq!(series, 296962999629);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQnaR7Wv3TSVmMAJjxZlOBr1nDwqJmkZQuS7BebkFuQdMVpr9yG-25zU_UPk969Mcx3q4vI9wRq5fLt/embed?start=false&loop=false&delayms=3000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e7.html">Q.7 10001st prime</a></li>
<li><a href="./e26.html">Q.26 Reciprocal cycles</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn mod_pow(a: u32, exp: u32, m: u32) -&gt; u32 {
    let (mut a, mut exp, m) = (a as u64, exp as u64, m as u64);
    if m == 1 {
        return 0;
    }
    if exp == 0 {
        return 1;
    }
    let mut result = 1;
    a %= m;
    loop {
        if exp % 2 == 1 {
            result *= a;
            result %= m;
        }
        exp &gt;&gt;= 1;
        if exp == 0 {
            break;
        }
        a *= a;
        a %= m;
    }
    result as u32
}

fn gcd(mut a: u32, mut b: u32) -&gt; u32 {
    if b &gt; a {
        std::mem::swap(&amp;mut a, &amp;mut b);
    }
    assert!(b != 0);
    let r = a % b;
    if r == 0 {
        return b;
    }
    gcd(b, r)
}

fn fermat_test(n: u32) -&gt; bool {
    gcd(223092870, n) == 1 &amp;&amp; mod_pow(223092870, n - 1, n) == 1
}

fn rule_out(sieve: &amp;mut Vec&lt;bool&gt;, prime: usize) {
    for i in (prime * prime..sieve.len()).step_by(prime) {
        sieve[i] = false;
    }
}

fn rule_out_from_previous_position(sieve: &amp;mut Vec&lt;bool&gt;, prime: usize, pp: usize) {
    for i in (prime * prime..sieve.len()).step_by(prime) {
        if i &lt; pp {
            continue;
        }
        sieve[i] = false;
    }
}

fn extend(sieve: &amp;mut Vec&lt;bool&gt;, primes: &amp;Vec&lt;usize&gt;) {
    let previous_len = sieve.len();
    sieve.extend(vec![true; previous_len]);
    for &amp;p in primes {
        rule_out_from_previous_position(sieve, p, previous_len);
    }
}

fn main() {
    let mut sum = 2u32 + 3;
    let mut sieve = vec![true; 1000];
    let mut primes: Vec&lt;usize&gt; = vec![];
    let mut cursor = 5usize;
    'sum_fill: loop {
        let ite = [2usize, 4].iter().cycle();
        for &amp;i in ite {
            if cursor &gt;= sieve.len() {
                break;
            }
            if !sieve[cursor] {
                cursor += i;
                continue;
            }
            &amp;primes.push(cursor);
            rule_out(&amp;mut sieve, cursor);
            sum += cursor as u32;
            if sum &gt;= 1_000_000 {
                sum -= cursor as u32;
                break 'sum_fill;
            }
            cursor += i;
        }
        extend(&amp;mut sieve, &amp;primes);
    }

    primes.insert(0, 2);
    primes.insert(1, 3);
    for p in primes {
        sum -= p as u32;
        if fermat_test(sum) {
            break;
        }
    }

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 997651);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">struct Sieve {
    _sieve: Vec&lt;bool&gt;,
}

impl Sieve {
    fn rule_out(&amp;mut self, prime: usize) {
        for i in (prime * prime..self._sieve.len()).step_by(prime) {
            self._sieve[i] = false;
        }
    }
    fn init(&amp;mut self) {
        let sqrt = (self._sieve.len() as f64).sqrt() as usize;
        let mut index = 5usize;
        for &amp;i in [2usize, 4].iter().cycle() {
            if index &gt; sqrt {
                break;
            }
            if self._sieve[index] {
                self.rule_out(index);
            }
            index += i;
        }
    }
    fn new(below: u32) -&gt; Self {
        assert!(below &gt; 4);
        let sieve = vec![true; below as usize];
        let mut s = Self { _sieve: sieve };
        s.init();
        s
    }
    fn is_prime(&amp;self, n: u32) -&gt; bool {
        assert!(n &lt; self._sieve.len() as u32);
        if n == 2 || n == 3 {
            return true;
        }
        if n == 0 || n == 1 || n % 2 == 0 || n % 3 == 0 {
            return false;
        }
        self._sieve[n as usize]
    }
    fn primes(&amp;self, below: u32) -&gt; Vec&lt;u32&gt; {
        let mut primes = vec![2u32, 3u32];
        let mut index = 5usize;
        for &amp;i in [2usize, 4].iter().cycle() {
            if index &gt;= below as usize {
                break;
            }
            if self._sieve[index] {
                primes.push(index as u32);
            }
            index += i;
        }
        primes
    }
}

fn fill_sum_up_to_million(primes: &amp;[u32]) -&gt; u32 {
    let mut sum = 0u32;
    for &amp;p in primes {
        sum += p;
        if sum &gt; 1_000_000 {
            sum -= p;
            return sum;
        }
    }
    panic!(&quot;The prime list was not enough to fill up the sum to be 1 million!&quot;);
}

fn main() {
    let sieve = Sieve::new(1_000_000);
    let primes = sieve.primes(1_000_000);
    let mut sum = fill_sum_up_to_million(&amp;primes);
    for p in primes {
        sum -= p;
        if sieve.is_prime(sum) {
            break;
        }
    }

    println!(&quot;{}&quot;, sum);
    assert_eq!(sum, 997651);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQJm3mT1CLx-9YH3ybCQqasFGWoM9_qCueUJbgrZNbWy4Ax0WwFAWN61iZwuqXY1DcxacaVL0in0AHh/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e31.html">Q.31 Coin sums</a></li>
</ul>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/GazC3A4OQTE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/EFg3u_E6eHU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<p>Since the dataset of the question is too large, it's using a mini set.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut table = vec![
        vec![131, 673, 234, 103, 18],
        vec![201, 96, 342, 965, 150],
        vec![630, 803, 746, 422, 111],
        vec![537, 699, 497, 121, 956],
        vec![805, 732, 524, 37, 331]
    ];
    for y in 0..table.len() {
        for x in 0..table[0].len() {
            table[y][x] += match (y, x) {
                (0, 0) =&gt; continue,
                (0, _) =&gt; table[y][x - 1],
                (_, 0) =&gt; table[y - 1][x],
                _ =&gt; std::cmp::min(table[y][x - 1], table[y - 1][x]),
            }
        }
    }
    let min = table[table.len() - 1][table[table.len() - 1].len() - 1];

    println!(&quot;{}&quot;, min);
    assert_eq!(min, 2427);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vS9AN5vh2mne6fSqg5Ecq7iQmNKIyQdZkCaCPHAYwICr_t1hob37FTxuWtYaJDKfqJ5UeA0l4jhtgEJ/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e31.html">Q.31 Coin sums</a></li>
<li><a href="./e81.html">Q.81 Path sum: two ways</a></li>
</ul>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/GazC3A4OQTE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/EFg3u_E6eHU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<p>Since the dataset of the question is too large, it's using a mini set.</p>
<pre><pre class="playground"><code class="language-rust editable">fn row_internal_loop(
    col: usize,
    row: usize,
    table: &amp;[[u32; 5]; 5],
    determineds: &amp;Vec&lt;u32&gt;,
) -&gt; u32 {
    let mut min = u32::MAX;
    {
        let mut d = 0u32;
        for r in (0..row).rev() {
            d += table[r][col];
            min = std::cmp::min(min, determineds[r] + d);
        }
    }
    min = std::cmp::min(min, determineds[row]);
    {
        let mut d = 0u32;
        for r in row + 1..table.len() {
            d += table[r][col];
            min = std::cmp::min(min, determineds[r] + d);
        }
    }
    min
}

fn main() {
    let table: [[u32; 5]; 5] = [
        [131, 673, 234, 103, 18],
        [201, 96, 342, 965, 150],
        [630, 803, 746, 422, 111],
        [537, 699, 497, 121, 956],
        [805, 732, 524, 37, 331]
    ];
    let mut determineds = vec![0u32; table.len()];
    let mut estimations = vec![0u32; table.len()];
    for col in 0..table[0].len() {
        for row in 0..table.len() {
            let min = row_internal_loop(col, row, &amp;table, &amp;determineds);
            estimations[row] = table[row][col] + min;
        }
        determineds.clone_from(&amp;estimations);
    }
    let min = estimations
        .iter()
        .min()
        .map(|&amp;m| m)
        .expect(&quot;the input table must have at least one row&quot;);

    println!(&quot;{}&quot;, min);
    assert_eq!(min, 994);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTjDpjdHztvfYfwBJI0Y6AfBvRVJ6puqK5lCzDKJrDvhjSeYBRYkdYz711H1n56riQwOhSHISt2J4ou/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<ul>
<li><a href="./e31.html">Q.31 Coin sums</a></li>
<li><a href="./e81.html">Q.81 Path sum: two ways</a></li>
<li><a href="./e82.html">Q.82 Path sum: three ways</a></li>
</ul>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/GazC3A4OQTE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/EFg3u_E6eHU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<p>Since the dataset of the question is too large, it's using a mini set.</p>
<ul>
<li><a href="https://growingspaghetti.github.io/e22.html#heap">Q.22 Names scores - Heap sort</a></li>
<li><a href="https://doc.rust-lang.org/std/collections/binary_heap/index.html">Module std::collections::binary_heap</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">use std::{cmp::Ordering, collections::BinaryHeap};

#[derive(Copy, Clone, Eq, PartialEq)]
struct Vertex {
    cost: u32,
    xy: (usize, usize),
}

impl Ord for Vertex {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        other.cost.cmp(&amp;self.cost)
    }
}

impl PartialOrd for Vertex {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}

fn update_adjacents(
    v: Vertex,
    table: &amp;[[u32; 5]; 5],
    visited: &amp;Vec&lt;Vec&lt;bool&gt;&gt;,
    estimations: &amp;mut Vec&lt;Vec&lt;u32&gt;&gt;,
    pq: &amp;mut BinaryHeap&lt;Vertex&gt;,
) {
    let Vertex { xy: (x, y), cost } = v;
    if y &gt; 0 {
        let t = y - 1;
        if !visited[t][x] {
            let e = &amp;mut estimations[t][x];
            *e = std::cmp::min(*e, table[t][x] + cost);
            pq.push(Vertex {
                cost: *e,
                xy: (x, t),
            });
        }
    }
    if x &lt; table[0].len() - 1 {
        let t = x + 1;
        if !visited[y][t] {
            let e = &amp;mut estimations[y][t];
            *e = std::cmp::min(*e, table[y][t] + cost);
            pq.push(Vertex {
                cost: *e,
                xy: (t, y),
            });
        }
    }
    if y &lt; table.len() - 1 {
        let t = y + 1;
        if !visited[t][x] {
            let e = &amp;mut estimations[t][x];
            *e = std::cmp::min(*e, table[t][x] + cost);
            pq.push(Vertex {
                cost: *e,
                xy: (x, t),
            });
        }
    }
    if x &gt; 0 {
        let t = x - 1;
        if !visited[y][t] {
            let e = &amp;mut estimations[y][t];
            *e = std::cmp::min(*e, table[y][t] + cost);
            pq.push(Vertex {
                cost: *e,
                xy: (t, y),
            });
        }
    }
}

fn suggest_next_vertex(pq: &amp;mut BinaryHeap&lt;Vertex&gt;, visited: &amp;Vec&lt;Vec&lt;bool&gt;&gt;) -&gt; Option&lt;Vertex&gt; {
    loop {
        match pq.pop() {
            None =&gt; return None,
            Some(v) if !visited[v.xy.1][v.xy.0] =&gt; return Some(v),
            _ =&gt; (),
        }
    }
}

fn main() {
    let table: [[u32; 5]; 5] = [
        [131, 673, 234, 103, 18],
        [201, 96, 342, 965, 150],
        [630, 803, 746, 422, 111],
        [537, 699, 497, 121, 956],
        [805, 732, 524, 37, 331]
    ];
    let (w, h) = (table[0].len(), table.len());
    let mut visited = vec![vec![false; w]; h];
    let mut estimations = vec![vec![u32::MAX; w]; h];

    estimations[0][0] = table[0][0];
    let mut pq = std::collections::BinaryHeap::&lt;Vertex&gt;::new();
    pq.push(Vertex {
        cost: estimations[0][0],
        xy: (0, 0),
    });
    let is_goal = |x, y| -&gt; bool { x == w - 1 &amp;&amp; y == h - 1 };
    let min = loop {
        let vertex = suggest_next_vertex(&amp;mut pq, &amp;visited)
            .expect(&quot;Goal was unreachable!&quot;);
        let (x, y) = vertex.xy;
        if is_goal(x, y) {
            break vertex.cost;
        }
        visited[y][x] = true;
        update_adjacents(vertex, &amp;table, &amp;visited, &amp;mut estimations, &amp;mut pq);
    };

    println!(&quot;{}&quot;, min);
    assert_eq!(min, 2297);
}
</code></pre></pre>
<hr />
<pre><pre class="playground"><code class="language-rust editable">fn update_adjacents(
    x: usize,
    y: usize,
    table: &amp;[[u32; 5]; 5],
    visited: &amp;Vec&lt;Vec&lt;bool&gt;&gt;,
    estimations: &amp;mut Vec&lt;Vec&lt;u32&gt;&gt;,
) {
    let cost = estimations[y][x];
    if y &gt; 0 {
        let t = y - 1;
        if !visited[t][x] {
            let e = &amp;mut estimations[t][x];
            *e = std::cmp::min(*e, table[t][x] + cost);
        }
    }
    if x &lt; table[0].len() - 1 {
        let t = x + 1;
        if !visited[y][t] {
            let e = &amp;mut estimations[y][t];
            *e = std::cmp::min(*e, table[y][t] + cost);
        }
    }
    if y &lt; table.len() - 1 {
        let t = y + 1;
        if !visited[t][x] {
            let e = &amp;mut estimations[t][x];
            *e = std::cmp::min(*e, table[t][x] + cost);
        }
    }
    if x &gt; 0 {
        let t = x - 1;
        if !visited[y][t] {
            let e = &amp;mut estimations[y][t];
            *e = std::cmp::min(*e, table[y][t] + cost);
        }
    }
}

fn suggest_next_vertex(
    table: &amp;[[u32; 5]; 5],
    visited: &amp;Vec&lt;Vec&lt;bool&gt;&gt;,
    estimations: &amp;Vec&lt;Vec&lt;u32&gt;&gt;,
) -&gt; Option&lt;(usize, usize)&gt; {
    let mut next: Option&lt;(usize, usize)&gt; = None;
    let mut minimum_estimation = u32::MAX;
    for y in 0..table.len() {
        for x in 0..table[0].len() {
            if visited[y][x] {
                continue;
            }
            if estimations[y][x] &lt; minimum_estimation {
                minimum_estimation = estimations[y][x];
                next = Some((x, y));
            }
        }
    }
    next
}

fn main() {
    let table: [[u32; 5]; 5] = [
        [131, 673, 234, 103, 18],
        [201, 96, 342, 965, 150],
        [630, 803, 746, 422, 111],
        [537, 699, 497, 121, 956],
        [805, 732, 524, 37, 331]
    ];
    let (w, h) = (table[0].len(), table.len());
    let mut visited = vec![vec![false; w]; h];
    let mut estimations = vec![vec![u32::MAX; w]; h];

    estimations[0][0] = table[0][0];
    let is_goal = |x, y| -&gt; bool { x == w - 1 &amp;&amp; y == h - 1 };
    let min = loop {
        let (x, y) = suggest_next_vertex(&amp;table, &amp;visited, &amp;estimations)
            .expect(&quot;Goal was unreachable!&quot;);
        if is_goal(x, y) {
            break estimations[y][x];
        }
        visited[y][x] = true;
        update_adjacents(x, y, &amp;table, &amp;visited, &amp;mut estimations);
    };

    println!(&quot;{}&quot;, min);
    assert_eq!(min, 2297);
}
</code></pre></pre>
<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTVFuy-K5jArjSaBThVuvaGhvhfmli2kFufNL9Brn1uAaaaKv6asucI1lvz5c3AmpZ5WTAgvu8rZ4j5/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>
<p><hrml><br></html></p>
<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/gMlf1ELvRzc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>
<ul>
<li><a href="l69.html#brute">1. Go to a brute force solution</a></li>
<li><a href="l69.html#newton">2. Go to Newton's method aka. Babylonian method solutions</a></li>
<li><a href="l69.html#digit">3. Go to digit-by-digit calculation solutions</a></li>
<li><a href="l69.html#bisection">4. Go to a bisection method solution</a></li>
</ul>
<p><a name="brute"><h2 id="1-brute-force"><a class="header" href="#1-brute-force">1. Brute force</a></h2></a></p>
<pre><pre class="playground"><code class="language-rust editable">use std::time::Instant;

pub fn square_root_brute(aa: u32) -&gt; u32 {
    let mut a = 0u32;
    while a as u64 * a as u64 &lt;= aa as u64 {
        a += 1;
    }
    a - 1
}

fn main() {
    let timer = Instant::now();
    for i in 0u32..100 {
        assert_eq!((i as f64).sqrt() as u32, square_root_brute(i));
    }
    for i in 2_147_395_500u32..2_147_395_601 {
        assert_eq!((i as f64).sqrt() as u32, square_root_brute(i));
    }
    println!(&quot;Time elapsed {:?}&quot;, timer.elapsed());
}
</code></pre></pre>
<hr />
<ul>
<li><a href="l69.html#brute">1. Go to a brute force solution</a></li>
<li><a href="l69.html#newton">2. Go to Newton's method aka. Babylonian method solutions</a></li>
<li><a href="l69.html#digit">3. Go to digit-by-digit calculation solutions</a></li>
<li><a href="l69.html#bisection">4. Go to a bisection method solution</a></li>
</ul>
<p><a name="newton"><h2 id="2-newtons-method"><a class="header" href="#2-newtons-method">2. Newton's method</a></h2></a></p>
<p><htlm><center><img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif" alt="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif"/></center></html></p>
<ul>
<li><a href="https://tour.golang.org/flowcontrol/8">https://tour.golang.org/flowcontrol/8</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">use std::time::Instant;

fn square_root_newton(a: u32) -&gt; u32 {
    let mut x = 1f32;
    let mut x_next: f32;
    loop {
        x_next = (x + a as f32 / x) / 2f32;
        if (x - x_next).abs() &lt; 0.1 {
            break x_next as u32;
        }
        x = x_next;
    }
}

fn main() {
    let timer = Instant::now();
    for i in 0u32..100 {
        assert_eq!((i as f32).sqrt() as u32, square_root_newton(i));
    }
    for i in 2_147_395_500u32..2_147_395_601 {
        assert_eq!((i as f32).sqrt() as u32, square_root_newton(i));
    }
    println!(&quot;Time elapsed {:?}&quot;, timer.elapsed());
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">use std::time::Instant;

fn square_root_newton(a: u32) -&gt; u32 {
    let mut x = 1f64;
    let mut x_next: f64;
    loop {
        x_next = (x + a as f64 / x) / 2f64;
        if (x - x_next).abs() &lt; 0.1 {
            break x_next as u32;
        }
        x = x_next;
    }
}

fn main() {
    let timer = Instant::now();
    for i in 0u32..100 {
        assert_eq!((i as f64).sqrt() as u32, square_root_newton(i));
    }
    for i in 2_147_395_500u32..2_147_395_601 {
        assert_eq!((i as f64).sqrt() as u32, square_root_newton(i));
    }
    println!(&quot;Time elapsed {:?}&quot;, timer.elapsed());
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">use std::time::Instant;

fn square_root_newton(a: u32) -&gt; u32 {
    let mut x = 1u64;
    let mut x_next: u64;
    loop {
        x_next = (x + a as u64 / x) / 2;
        if x == x_next || x_next * x_next &lt;= a as u64 {
            break x_next as u32;
        }
        x = x_next;
    }
}

fn main() {
    let timer = Instant::now();
    for i in 0u32..100 {
        assert_eq!((i as f64).sqrt() as u32, square_root_newton(i));
    }
    for i in 2_147_395_500u32..2_147_395_601 {
        assert_eq!((i as f64).sqrt() as u32, square_root_newton(i));
    }
    println!(&quot;Time elapsed {:?}&quot;, timer.elapsed());
}
</code></pre></pre>
<ul>
<li><a href="https://play.golang.org/p/U0T1OYFhzIu">The Go Playground</a></li>
</ul>
<hr />
<ul>
<li><a href="l69.html#brute">1. Go to a brute force solution</a></li>
<li><a href="l69.html#newton">2. Go to Newton's method aka. Babylonian method solutions</a></li>
<li><a href="l69.html#digit">3. Go to digit-by-digit calculation solutions</a></li>
<li><a href="l69.html#bisection">4. Go to a bisection method solution</a></li>
</ul>
<p><a name="digit"><h2 id="3-digit-by-digit-calculation"><a class="header" href="#3-digit-by-digit-calculation">3. Digit-by-digit calculation</a></h2></a></p>
<html><center><img src="./imgs/sqrt-digit.gif"></center></html>
<pre><pre class="playground"><code class="language-rust editable">use std::time::Instant;

fn subtract_largest_block_from_carry(carry: &amp;mut u32, divisor: &amp;mut u32, x: &amp;mut u32) {
    for i in (0u32..10).rev() {
        let block = (*divisor + i) * i;
        if block &gt; *carry {
            continue;
        }
        *carry -= block;
        *divisor += i * 2;
        *x += i;
        break;
    }
}

fn square_root_digit_by_digit(mut a: u32) -&gt; u32 {
    let mut digits = vec![];
    while a &gt; 0 {
        digits.push(a % 100);
        a /= 100;
    }
    let (mut x, mut divisor, mut carry) = (0u32, 0u32, 0u32);
    for &amp;n in digits.iter().rev() {
        carry = carry * 100 + n;
        divisor *= 10;
        x *= 10;
        subtract_largest_block_from_carry(&amp;mut carry, &amp;mut divisor, &amp;mut x);
    }
    x
}

fn main() {
    let timer = Instant::now();
    for i in 0u32..100 {
        assert_eq!((i as f64).sqrt() as u32, square_root_digit_by_digit(i));
    }
    for i in 2_147_395_500u32..2_147_395_601 {
        assert_eq!((i as f64).sqrt() as u32, square_root_digit_by_digit(i));
    }
    println!(&quot;Time elapsed {:?}&quot;, timer.elapsed());
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">use std::time::Instant;

fn square_root_digit_by_digit(mut a: u32) -&gt; u32 {
    let mut x = 0u32;
    let mut bit: u32 = 0b01000000000000000000000000000000;
    while bit &gt; a {
        bit &gt;&gt;= 2;
    }
    while bit != 0 {
        let block = x + bit;
        x &gt;&gt;= 1;
        if a &gt;= block {
            a -= block;    
            x += bit;
        }
        bit &gt;&gt;= 2;
    }
    x
}

fn main() {
    let timer = Instant::now();
    for i in 0u32..100 {
        assert_eq!((i as f64).sqrt() as u32, square_root_digit_by_digit(i));
    }
    for i in 2_147_395_500u32..2_147_395_601 {
        assert_eq!((i as f64).sqrt() as u32, square_root_digit_by_digit(i));
    }
    println!(&quot;Time elapsed {:?}&quot;, timer.elapsed());
}
</code></pre></pre>
<hr />
<ul>
<li><a href="l69.html#brute">1. Go to a brute force solution</a></li>
<li><a href="l69.html#newton">2. Go to Newton's method aka. Babylonian method solutions</a></li>
<li><a href="l69.html#digit">3. Go to digit-by-digit calculation solutions</a></li>
<li><a href="l69.html#bisection">4. Go to a bisection method solution</a></li>
</ul>
<p><a name="bisection"><h2 id="4-bisection-method"><a class="header" href="#4-bisection-method">4. Bisection method</a></h2></a></p>
<pre><pre class="playground"><code class="language-rust editable">use std::time::Instant;
use std::cmp::Ordering;

fn square_root_bisection(mut a: u32) -&gt; u32 {
    let (mut top, mut bottom) = (a.clone() as f64, 0f64);
    loop {
        if top - bottom &lt; 0.00001 {
            break top as u32;
        }
        let median = bottom + (top - bottom) / 2f64;
        match (&amp;(a as f64)).partial_cmp(&amp;(median * median)).unwrap() {
            Ordering::Less =&gt; top = median,
            Ordering::Equal =&gt; return median as u32,
            Ordering::Greater =&gt; bottom = median,
        }
    }
}

fn main() {
    let timer = Instant::now();
    for i in 0u32..100 {
        assert_eq!((i as f64).sqrt() as u32, square_root_bisection(i));
    }
    for i in 2_147_395_500u32..2_147_395_601 {
        assert_eq!((i as f64).sqrt() as u32, square_root_bisection(i));
    }
    println!(&quot;Time elapsed {:?}&quot;, timer.elapsed());
}
</code></pre></pre>
<p>This website is a collection of Ryoji's memos in <a href="https://github.com/growingspaghetti/project-euler">github.com/growingspaghetti/project-euler</a> as the scrapbox.</p>
<!-- toc -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
