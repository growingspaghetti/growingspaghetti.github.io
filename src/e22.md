<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vStc3yljpxd5sfgEk-ArIhJFDLxVJham5kt16FnLCrlxS0-6RKTLO-aacD6WrxPyR26UO8S_tdfpteF/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>

* [mycodeschool - Sorting Algorithms, youtube playlist](https://www.youtube.com/playlist?list=PL2_aWCzGMAwKedT2KfDMB9YA5DgASZb3U)

Because the original name list is very long, these examples have only a part of it.

```rust
fn median<'a>(vec: &[&'a str], a: usize, c: usize) -> &'a str {
    let b = (c - a) / 2;
    let (astr, bstr, cstr) = (vec[a], vec[b], vec[c]);
    if (cstr < astr && astr < bstr) || (bstr <= astr && astr < cstr) {
        astr
    } else if (astr < bstr && bstr < cstr) || (cstr < bstr && bstr <= astr) {
        bstr
    } else {
        cstr
    }
}

fn met(sinker_depth: usize, float_depth: usize) -> bool {
    sinker_depth >= float_depth
}

fn sink_fully(vec: &[&str], depth: &mut usize, blocker: &str) {
    while vec[*depth] < blocker {
        *depth += 1;
    }
}

fn float_fully(vec: &[&str], depth: &mut usize, blocker: &str) {
    while vec[*depth] > blocker {
        *depth -= 1;
    }
}

fn break_through(vec: &mut [&str], sinker_depth: &mut usize, float_depth: &mut usize) {
    vec.swap(*sinker_depth, *float_depth);
    *sinker_depth += 1;
    *float_depth -= 1;
}

fn release(vec: &mut [&str], sinker0: usize, float0: usize) {
    if met(sinker0, float0) {
        return;
    }
    match float0 - sinker0 {
        1 => {
            if vec[sinker0] > vec[sinker0 + 1] {
                vec.swap(sinker0, sinker0 + 1);
            }
            return;
        }
        2 => {
            if vec[sinker0] > vec[sinker0 + 1] {
                vec.swap(sinker0, sinker0 + 1);
            }
            if vec[sinker0 + 1] > vec[sinker0 + 2] {
                vec.swap(sinker0 + 1, sinker0 + 2);
            }
            if vec[sinker0] > vec[sinker0 + 1] {
                vec.swap(sinker0, sinker0 + 1);
            }
            return;
        }
        _ => (),
    }
    let pivot = median(vec, sinker0, float0);
    let mut sinker = sinker0;
    let mut float = float0;
    loop {
        sink_fully(vec, &mut sinker, pivot);
        float_fully(vec, &mut float, pivot);
        if met(sinker, float) {
            break;
        }
        break_through(vec, &mut sinker, &mut float);
    }
    println!("pivot: {}", pivot);
    println!("{:#?}", &vec[sinker0..=sinker - 1]);
    println!("{:#?}", &vec[float + 1..=float0]);
    release(vec, sinker0, sinker - 1);
    release(vec, float + 1, float0);
}

fn quick_sort(vec: &mut [&str]) {
    release(vec, 0, vec.len() - 1);
}

fn name_score(index: usize, name: &str) -> u32 {
    let position = index as u32 + 1;
    let worth = name.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::<u32>();
    position * worth
}

fn main() {
    let mut names = NAMES.to_vec();
    quick_sort(&mut names);
    let sum: u32 = names
        .iter()
        .enumerate()
        .map(|(i, &n)| name_score(i, n))
        .sum();

    println!("---\n{:#?}", names);
    println!("{}", sum);
    assert_eq!(sum, 26578);
}

const NAMES: &[&str] = &[
    "MARY",
    "PATRICIA",
    "LINDA",
    "BARBARA",
    "ELIZABETH",
    "JENNIFER",
    "MARIA",
    "SUSAN",
    "MARGARET",
    "DOROTHY",
    "LISA",
    "NANCY",
    "KAREN",
    "BETTY",
    "HELEN",
    "SANDRA",
    "DONNA",
    "CAROL",
    "RUTH",
    "SHARON",
    "MICHELLE",
    "LAURA",
    "SARAH",
    "KIMBERLY",
    "DEBORAH",
    "JESSICA",
    "SHIRLEY",
    "CYNTHIA",
];
```

---

```rust
fn drain_into<'a>(a: &[&'a str], b: &[&'a str], ab: &mut [&'a str]) {
    let (mut x, mut y, mut i) = (0, 0, 0);
    while x < a.len() && y < b.len() {
        if a[x] < b[y] {
            ab[i] = a[x];
            x += 1;
        } else {
            ab[i] = b[y];
            y += 1;
        }
        i += 1;
    }
    if x < a.len() {
        ab[i..].copy_from_slice(&a[x..]);
    }
    if y < b.len() {
        ab[i..].copy_from_slice(&b[y..]);
    }
}

fn merge_sort(segment: &mut [&str]) {
    let n = segment.len();
    let m = n / 2;
    if n <= 1 {
        return;
    }
    merge_sort(&mut segment[0..m]);
    merge_sort(&mut segment[m..n]);
    println!("---\n{:#?}", &segment[0..m]);
    println!("{:#?}", &segment[m..n]);

    let mut tmp: Vec<&str> = segment.to_vec();
    drain_into(&segment[0..m], &segment[m..n], &mut tmp[..]);
    segment.copy_from_slice(&tmp);
    println!("{:#?}", &segment);
}

fn name_score(index: usize, name: &str) -> u32 {
    let position = index as u32 + 1;
    let worth = name.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::<u32>();
    position * worth
}

fn main() {
    let mut names = NAMES.to_vec();
    merge_sort(&mut names);
    let sum: u32 = names
        .iter()
        .enumerate()
        .map(|(i, &n)| name_score(i, n))
        .sum();

    println!("---\n{:#?}", names);
    println!("{}", sum);
    assert_eq!(sum, 26578);
}

const NAMES: &[&str] = &[
    "MARY",
    "PATRICIA",
    "LINDA",
    "BARBARA",
    "ELIZABETH",
    "JENNIFER",
    "MARIA",
    "SUSAN",
    "MARGARET",
    "DOROTHY",
    "LISA",
    "NANCY",
    "KAREN",
    "BETTY",
    "HELEN",
    "SANDRA",
    "DONNA",
    "CAROL",
    "RUTH",
    "SHARON",
    "MICHELLE",
    "LAURA",
    "SARAH",
    "KIMBERLY",
    "DEBORAH",
    "JESSICA",
    "SHIRLEY",
    "CYNTHIA",
];
```

---

```rust
fn bubble_sort(vec: &mut Vec<&str>) {
    for i in 0..vec.len() {
        let mut swap_was_required = false;
        for j in 0..vec.len() - i - 1 {
            if vec[j] > vec[j + 1] {
                vec.swap(j, j + 1);
                swap_was_required = true;
            }
        }
        println!("---\n{:#?}", &vec[0..vec.len() - i - 1]);
        println!("{:#?}", &vec[vec.len() - i - 1..vec.len()]);
        if !swap_was_required {
            break;
        }
    }
}

fn name_score(index: usize, name: &str) -> u32 {
    let position = index as u32 + 1;
    let worth = name.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::<u32>();
    position * worth
}

fn main() {
    let mut names = NAMES.to_vec();
    bubble_sort(&mut names);
    let sum: u32 = names
        .iter()
        .enumerate()
        .map(|(i, &n)| name_score(i, n))
        .sum();

    println!("---\n{:#?}", names);
    println!("{}", sum);
    assert_eq!(sum, 26578);
}

const NAMES: &[&str] = &[
    "MARY",
    "PATRICIA",
    "LINDA",
    "BARBARA",
    "ELIZABETH",
    "JENNIFER",
    "MARIA",
    "SUSAN",
    "MARGARET",
    "DOROTHY",
    "LISA",
    "NANCY",
    "KAREN",
    "BETTY",
    "HELEN",
    "SANDRA",
    "DONNA",
    "CAROL",
    "RUTH",
    "SHARON",
    "MICHELLE",
    "LAURA",
    "SARAH",
    "KIMBERLY",
    "DEBORAH",
    "JESSICA",
    "SHIRLEY",
    "CYNTHIA",
];
```
---
```rust
fn selection_sort(vec: &mut Vec<&str>) {
    for i in 0..vec.len() {
        let mut min_index = i;
        for j in (i + 1)..vec.len() {
            if vec[j] < vec[min_index] {
                min_index = j;
            }
        }
        vec.swap(i, min_index);
        println!("---\n{:#?}", &vec[0..=i]);
        println!("{:#?}", &vec[std::cmp::min(i + 1, vec.len())..vec.len()]);
    }
}

fn name_score(index: usize, name: &str) -> u32 {
    let position = index as u32 + 1;
    let worth = name.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::<u32>();
    position * worth
}

fn main() {
    let mut names = NAMES.to_vec();
    selection_sort(&mut names);
    let sum: u32 = names
        .iter()
        .enumerate()
        .map(|(i, &n)| name_score(i, n))
        .sum();

    println!("---\n{:#?}", names);
    println!("{}", sum);
    assert_eq!(sum, 26578);
}

const NAMES: &[&str] = &[
    "MARY",
    "PATRICIA",
    "LINDA",
    "BARBARA",
    "ELIZABETH",
    "JENNIFER",
    "MARIA",
    "SUSAN",
    "MARGARET",
    "DOROTHY",
    "LISA",
    "NANCY",
    "KAREN",
    "BETTY",
    "HELEN",
    "SANDRA",
    "DONNA",
    "CAROL",
    "RUTH",
    "SHARON",
    "MICHELLE",
    "LAURA",
    "SARAH",
    "KIMBERLY",
    "DEBORAH",
    "JESSICA",
    "SHIRLEY",
    "CYNTHIA",
];
```
---
```rust
fn insertion_sort(vec: &mut [&str]) {
    for i in 0..vec.len() {
        for j in (0..i).rev() {
            if vec[j] < vec[j + 1] {
                break;
            }
            vec.swap(j, j + 1);
        }
        println!("---\n{:#?}", &vec[0..=i]);
        println!("{:#?}", &vec[std::cmp::min(i + 1, vec.len())..vec.len()]);
    }
}

fn name_score(index: usize, name: &str) -> u32 {
    let position = index as u32 + 1;
    let worth = name.chars().map(|c| c as u32 - 'A' as u32 + 1).sum::<u32>();
    position * worth
}

fn main() {
    let mut names = NAMES.to_vec();
    insertion_sort(&mut names);
    let sum: u32 = names
        .iter()
        .enumerate()
        .map(|(i, &n)| name_score(i, n))
        .sum();

    println!("---\n{:#?}", names);
    println!("{}", sum);
    assert_eq!(sum, 26578);
}

const NAMES: &[&str] = &[
    "MARY",
    "PATRICIA",
    "LINDA",
    "BARBARA",
    "ELIZABETH",
    "JENNIFER",
    "MARIA",
    "SUSAN",
    "MARGARET",
    "DOROTHY",
    "LISA",
    "NANCY",
    "KAREN",
    "BETTY",
    "HELEN",
    "SANDRA",
    "DONNA",
    "CAROL",
    "RUTH",
    "SHARON",
    "MICHELLE",
    "LAURA",
    "SARAH",
    "KIMBERLY",
    "DEBORAH",
    "JESSICA",
    "SHIRLEY",
    "CYNTHIA",
];
```
