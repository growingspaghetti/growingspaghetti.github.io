<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vRoiWWblcSHsZfzlRjD8JN9zSxxlT7YkOgkrY06vvNEkkwsxw3YHISIR7ioJsQfNgzC-Yl-6DVieOVN/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>

```rust
fn match_pow_sum(target: u32, power_ninefold: &[u32]) -> bool {
    let mut digits = target;
    let mut sum = 0;
    while digits > 0 {
        let d = digits % 10;
        digits /= 10;
        if d == 0 {
            continue;
        }
        sum += power_ninefold[d as usize - 1];
        if sum > target {
            return false;
        }
    }
    sum == target
}

fn digit_range_max(powed_nine: u32) -> u32 {
    let mut digit_min = 1u32;
    let mut pow_sum_max = powed_nine;
    while digit_min < pow_sum_max {
        digit_min *= 10;
        pow_sum_max += powed_nine;
    }
    pow_sum_max - powed_nine
}

fn main() {
    let e = 5;
    let power_ninefold = (1..=9u32).map(|n| n.pow(e)).collect::<Vec<u32>>();
    let digits_max = digit_range_max(power_ninefold[8]);
    let sum = (2..=digits_max)
        .filter(|&d| match_pow_sum(d, &power_ninefold))
        .sum::<u32>();

    println!("{}", sum);
    assert_eq!(sum, 443839);
}
```
