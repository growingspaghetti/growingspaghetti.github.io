<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTUzg1DwUVVPjMo47WhaQsHfCnvNIQ7Kkon5Bap_TWFpgsErv3FrrGagF_zJpF0G50ThPSkBoiGvq9B/embed?start=false&loop=false&delayms=60000" frameborder="0" width="750" height="460" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>

<html>
<button class="accordion" onclick="toggle('the-accordion');">Problem / 問</button>
<div id="the-accordion" class="panel w3-hide">
Problem 12 "Highly divisible triangular number"

<p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7<sup>th</sup> triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:</p>
<p class="center">1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...</p>
<p>Let us list the factors of the first seven triangle numbers:</p>
<blockquote class="monospace"><b> 1</b>: 1<br /><b> 3</b>: 1,3<br /><b> 6</b>: 1,2,3,6<br /><b>10</b>: 1,2,5,10<br /><b>15</b>: 1,3,5,15<br /><b>21</b>: 1,3,7,21<br /><b>28</b>: 1,2,4,7,14,28</blockquote>
<p>We can see that 28 is the first triangle number to have over five divisors.</p>
<p>What is the value of the first triangle number to have over five hundred divisors?</p>

問 12 「高度整除三角数」

三角数の数列は自然数の和で表わされ, 7番目の三角数は 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28 である. 三角数の最初の10項は:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

となる.

最初の7項について, その約数を列挙すると, 以下のとおり.

<blockquote class="monospace"><b> 1</b>: 1<br /><b> 3</b>: 1,3<br /><b> 6</b>: 1,2,3,6<br /><b>10</b>: 1,2,5,10<br /><b>15</b>: 1,3,5,15<br /><b>21</b>: 1,3,7,21<br /><b>28</b>: 1,2,4,7,14,28</blockquote>

これから, 7番目の三角数である28は, 5個より多く約数をもつ最初の三角数であることが分かる.

では, 500個より多く約数をもつ最初の三角数はいくつか.
</div>
</html>


- [Q.3 Largest prime factor](./e3.md)

```rust,editable
struct TriangleNumber {
    _nth: u64,
    _primes: Vec<u64>,
    _num_div_even: u64,
    _num_div_odd: u64,
}

trait Divisors {
    fn number_of_divisors(&self) -> u64;
}

impl TriangleNumber {
    fn new() -> Self {
        Self {
            _nth: 3,
            _num_div_even: 2,
            _num_div_odd: 2,
            _primes: vec![2, 3],
        }
    }
    fn num(&self) -> u64 {
        self._nth * (self._nth + 1) / 2
    }
    fn _divide_fully(&self, n: &mut u64, d: u64, side: &mut u64, count: &mut u64) {
        if *n % d != 0 {
            return;
        }
        let mut exp = 0u64;
        while {
            *n /= d;
            exp += 1;
            *n % d == 0
        } {}
        *side = (*n as f64).sqrt() as u64;
        *count *= exp + 1;
    }
    fn _num_of_divisors(&mut self, mut n: u64) -> u64 {
        let mut count = 1u64;
        let mut side = (n as f64).sqrt() as u64;
        for p in &self._primes {
            if p > side || n == 1 {
                break;
            }
            self._divide_fully(&mut n, p, &mut side, &mut count);
        }
        if n != 1 {
            count *= 2;
            self._primes.push(n);
        }
        count
    }
    fn increment(&mut self) {
        self._nth += 1;
        if self._nth % 2 == 0 {
            self._num_div_odd = self._num_of_divisors(self._nth + 1);
        } else {
            self._num_div_even = self._num_of_divisors((self._nth + 1) / 2);
        }
    }
}

impl Divisors for TriangleNumber {
    fn number_of_divisors(&self) -> u64 {
        self._num_div_even * self._num_div_odd
    }
}

fn main() {
    let mut triangle_number = TriangleNumber::new();
    while triangle_number.number_of_divisors() <= 500 {
        triangle_number.increment();
    }
    let ans = triangle_number.num();

    println!("{}", ans);
    assert_eq!(ans, 76576500);
}
```

<html><center><iframe width="560" height="315" src="https://www.youtube.com/embed/WzkW3P7HPvs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center></html>

- [Highly_composite_number - Wikipedia](https://en.wikipedia.org/wiki/Highly_composite_number)
