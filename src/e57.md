<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQdi9g1mqnCGEthsKRRZ0lWh3bohmWv_7JHtGeTdVq4c0P3LSTPiSvCprfj23XS3mhP_dRp0dn0q1Vm/embed?start=false&loop=false&delayms=60000" frameborder="0" width="760" height="490" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>

- [Smallest multiple](./e5.md)
- [Reciprocal cycles](./e26.md)

```rust,editable
struct Fraction {
    deno_prev: u64,
    deno: u64,
    nume: u64,
    n: u32,
}

impl Fraction {
    fn new() -> Self {
        let deno_prev = 2u64;
        let deno = 5u64;
        Self {
            deno_prev,
            deno,
            nume: deno_prev + deno,
            n: 2,
        }
    }
    fn increment(&mut self) {
        self.n += 1;
        self.deno_prev = self.deno;
        self.deno += self.nume;
        self.nume = self.deno_prev + self.deno;
        const THRESHOLD: u64 = {
            let mut threshold = 1u64;
            while threshold < u64::MAX / 100 {
                threshold *= 10;
            }
            threshold
        };
        if self.deno > THRESHOLD && self.nume > THRESHOLD {
            self.deno /= 10;
            self.nume /= 10;
        }
    }
    fn has_numerator_more_digits(&self) -> bool {
        let mut n = self.nume;
        let mut d = self.deno;
        while n > 0 && d > 0 {
            n /= 10;
            d /= 10;
        }
        n > d
    }
}

fn main() {
    let mut count = 0u32;
    let mut frac = Fraction::new();
    while {
        if frac.has_numerator_more_digits() {
            count += 1;
        }
        frac.increment();
        frac.n <= 1000
    } {}

    println!("{}", count);
    assert_eq!(count, 153);
}
```
