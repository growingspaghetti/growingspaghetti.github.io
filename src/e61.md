<html><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTv_HCp35CU4-IrGgnqteqzttc9_u1pD3VFGUbBK_kBh6KWlzaWJvkzmP0bfxZo0y7mJLEegZgMGSrc/embed?start=false&loop=false&delayms=60000" frameborder="0" width="760" height="490" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></html>

<html>
<button class="accordion" onclick="toggle('the-accordion');">Problem / 問</button>
<div id="the-accordion" class="panel w3-hide">
Problem 61 "Cyclical figurate numbers"

<p>Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:</p>
<table><tr><td>Triangle</td>
<td> </td>
<td>P<sub>3,<i>n</i></sub>=<i>n</i>(<i>n</i>+1)/2</td>
<td> </td>
<td>1, 3, 6, 10, 15, ...</td>
</tr><tr><td>Square</td>
<td> </td>
<td>P<sub>4,<i>n</i></sub>=<i>n</i><sup>2</sup></td>
<td> </td>
<td>1, 4, 9, 16, 25, ...</td>
</tr><tr><td>Pentagonal</td>
<td> </td>
<td>P<sub>5,<i>n</i></sub>=<i>n</i>(3<i>n</i>−1)/2</td>
<td> </td>
<td>1, 5, 12, 22, 35, ...</td>
</tr><tr><td>Hexagonal</td>
<td> </td>
<td>P<sub>6,<i>n</i></sub>=<i>n</i>(2<i>n</i>−1)</td>
<td> </td>
<td>1, 6, 15, 28, 45, ...</td>
</tr><tr><td>Heptagonal</td>
<td> </td>
<td>P<sub>7,<i>n</i></sub>=<i>n</i>(5<i>n</i>−3)/2</td>
<td> </td>
<td>1, 7, 18, 34, 55, ...</td>
</tr><tr><td>Octagonal</td>
<td> </td>
<td>P<sub>8,<i>n</i></sub>=<i>n</i>(3<i>n</i>−2)</td>
<td> </td>
<td>1, 8, 21, 40, 65, ...</td>
</tr></table><p>The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.</p>
<ol><li>The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).</li>
<li>Each polygonal type: triangle (P<sub>3,127</sub>=8128), square (P<sub>4,91</sub>=8281), and pentagonal (P<sub>5,44</sub>=2882), is represented by a different number in the set.</li>
<li>This is the only set of 4-digit numbers with this property.</li>
</ol><p>Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.</p>



問 61 「巡回図形数」

三角数, 四角数, 五角数, 六角数, 七角数, 八角数は多角数であり, それぞれ以下の式で生成される.

3つの4桁の数の順番付きの集合 (8128, 2882, 8281) は以下の面白い性質を持つ.

- この集合は巡回的である. 最後の数も含めて, 各数の後半2桁は次の数の前半2桁と一致する
- それぞれ多角数である: 三角数 (P<sub>3,127</sub>=8128), 四角数 (P<sub>4,91</sub>=8281), 五角数 (P<sub>5,44</sub>=2882) がそれぞれ別の数字で集合に含まれている
- 4桁の数の組で上の2つの性質をもつはこの組だけである.

三角数, 四角数, 五角数, 六角数, 七角数, 八角数が全て表れる6つの巡回する4桁の数からなる唯一の順序集合の和を求めよ.

</div>
</html>

- [Q.12 Highly divisible triangular number](./e12.md)
- [Q.42 Coded triangle numbers](./e42.md)
- [Q.44 Pentagon numbers](./e44.md)
- [Q.45 Triangular, pentagonal, and hexagonal](./e45.md)

```rust,editable
#[derive(Debug)]
struct PolyNum {
    left: u8,
    right: u8,
    side_ident: u8,
}

fn next(filter: u8, polynums: &[PolyNum], chain: &[&PolyNum]) -> Option<u32> {
    if filter == 0b11111100 {
        if chain[chain.len() - 1].right != chain[0].left {
            return None;
        }
        println!("{:#?}", chain);
        let sum = chain
            .iter()
            .map(|&pn| pn.left as u32 * 100 + pn.right as u32)
            .sum();
        return Some(sum);
    }
    let oks = polynums
        .iter()
        .filter(|&pn| pn.left == chain[chain.len() - 1].right)
        .filter(|&pn| pn.side_ident & filter == 0)
        .collect::<Vec<&PolyNum>>();
    for pn in oks {
        let chain = chain
            .iter()
            .map(|&p| p)
            .chain(std::iter::once(pn))
            .collect::<Vec<&PolyNum>>();
        let child = next(filter | pn.side_ident, polynums, &chain);
        if child.is_some() {
            return child;
        }
    }
    None
}

fn generate_four_digit_polygonal_numbers(side: u32) -> Vec<PolyNum> {
    let polygonal_number_genenerator_builder =
        |side: u32| move |n: u32| (side - 2) * n * (n - 1) / 2 + n;

    let gen = polygonal_number_genenerator_builder(side);
    let mut polynums = vec![];
    for n in 1u32.. {
        let x = gen(n);
        if x > 9999 {
            break;
        }
        if x < 1000 {
            continue;
        }
        polynums.push(PolyNum {
            left: (x / 100) as u8,
            right: (x % 100) as u8,
            side_ident: 1 << (side - 1),
        });
    }
    polynums
}

fn cyclical_figurate_numbers() -> u32 {
    let octs = generate_four_digit_polygonal_numbers(8);

    let mut polynums = vec![];
    for s in 3u32..=7 {
        polynums.extend(generate_four_digit_polygonal_numbers(s).into_iter());
    }

    for oct in &octs {
        if let Some(sum) = next(oct.side_ident, &polynums, &vec![oct]) {
            return sum;
        }
    }
    unreachable!();
}

fn main() {
   let ans = cyclical_figurate_numbers();
   println!("{}", ans);
   assert_eq!(ans, 28684);
}
```
